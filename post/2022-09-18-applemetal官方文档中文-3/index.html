<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Apple Metal文档（3）：使用渲染管线渲染图形 - Ingslh's Blog</title><meta name=description content="渲染一个简单的2D三角形"><meta name=author content="ingslh"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Ingslh\u0027s Blog","url":"https:\/\/ingslh.com"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/ingslh.com"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/ingslh.com","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/ingslh.com\/post\/2022-09-18-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-3\/","name":"Apple metal文档（3）：使用渲染管线渲染图形"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"ingslh"},"headline":"Apple Metal文档（3）：使用渲染管线渲染图形","description":" 本文翻译自苹果Metal的官方文档：Using a Render Pipeline to Render Primitives，目的主要是为了加深自己的理解，如果哪里翻译有误，请大家指出，我会及时更正。欢迎转载，但禁止用于商业用途。谢谢！\n","inLanguage":"en","wordCount":4079,"datePublished":"2022-09-18T00:00:00","dateModified":"2022-09-18T00:00:00","image":"https:\/\/ingslh.com\/img\/actover.jpeg","keywords":["Metal"],"mainEntityOfPage":"https:\/\/ingslh.com\/post\/2022-09-18-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-3\/","publisher":{"@type":"Organization","name":"https:\/\/ingslh.com","logo":{"@type":"ImageObject","url":"https:\/\/ingslh.com\/img\/actover.jpeg","height":60,"width":60}}}</script><meta property="og:title" content="Apple Metal文档（3）：使用渲染管线渲染图形"><meta property="og:description" content="渲染一个简单的2D三角形"><meta property="og:image" content="https://ingslh.com/img/actover.jpeg"><meta property="og:url" content="https://ingslh.com/post/2022-09-18-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-3/"><meta property="og:type" content="website"><meta property="og:site_name" content="Ingslh's Blog"><meta name=twitter:title content="Apple Metal文档（3）：使用渲染管线渲染图形"><meta name=twitter:description content="渲染一个简单的2D三角形"><meta name=twitter:image content="https://ingslh.com/img/actover.jpeg"><meta name=twitter:card content="summary"><meta name=twitter:site content="@Ingslh_lzh"><meta name=twitter:creator content="@Ingslh_lzh"><link href=https://ingslh.com/img/i.png rel=icon type=image/x-icon><meta name=generator content="Hugo 0.111.1"><link rel=alternate href=https://ingslh.com/index.xml type=application/rss+xml title="Ingslh's Blog"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://ingslh.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://ingslh.com/css/highlight.min.css><link rel=stylesheet href=https://ingslh.com/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-45SBK23QXE","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://ingslh.com>Ingslh's Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Home href=/>Home</a></li><li><a title=Posts href=/post>Posts</a></li><li><a title=About href=/page/about/>About</a></li><li><a title=Tags href=/tags>Tags</a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Ingslh's Blog" href=https://ingslh.com><img class=avatar-img src=https://ingslh.com/img/actover.jpeg alt="Ingslh's Blog"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Apple Metal文档（3）：使用渲染管线渲染图形</h1><h2 class=post-subheading>渲染一个简单的2D三角形</h2><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on September 18, 2022
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;9&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;4079&nbsp;words</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><blockquote><p>本文翻译自苹果Metal的官方文档：<a href=https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives>Using a Render Pipeline to Render Primitives</a>，目的主要是为了加深自己的理解，如果哪里翻译有误，请大家指出，我会及时更正。欢迎转载，但禁止用于商业用途。谢谢！</p></blockquote><h2 id=概述>概述</h2><p>这个例程向你展示了如何配置一个渲染管线，并作为渲染通道一部分去绘制一个简单的2D三角形到视图中。该示例为每个顶点提供了位置和颜色信息，渲染管道使用该数据渲染三角形，并为三角形顶点指定的颜色之间插入颜色值。</p><p><img src=/img/0918/vertex_img.png alt=顶点数据></p><p>Xcode 项目包含用于在 macOS、iOS 和 tvOS 上运行示例的方案。</p><h2 id=理解metal渲染管线>理解Metal渲染管线</h2><p>渲染管线（pipline）用于处理绘图指令，并将图元数据写到渲染通道的目标中去。一个渲染管线会有很多阶段，其中一些需要使用着色器进行编程，另一些具有固定或可配置的属性。这个例程聚焦于渲染管线的三个主要阶段：顶点阶段、光栅化阶段和片段阶段，其中顶点阶段和片段阶段是可编程的，因此需要使用Metal着色器语言（MSL），而在光栅化阶段是被固定的。</p><p><img src=/img/0918/pipline.png alt=pipline></p><p>渲染首先通过一个绘图命令开始，包含顶点数量，需要绘制什么样的图形。下面是例程中的绘图指令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=c1>// Draw the triangle.</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>renderEncoder</span> <span class=n>drawPrimitives</span><span class=p>:</span><span class=n>MTLPrimitiveTypeTriangle</span>
</span></span><span class=line><span class=cl>                  <span class=n>vertexStart</span><span class=p>:</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>                  <span class=n>vertexCount</span><span class=p>:</span><span class=mi>3</span><span class=p>];</span>
</span></span></code></pre></div><p>在顶点阶段会为每个顶点提供坐标信息，当顶点被处理完成，渲染管线会对图形进行光栅化处理，以确定渲染目标中的哪些像素位于图形的边界内。在片段阶段会确定这些像素的颜色值，并把它们写到渲染目标中。</p><p>在本示例的其余部分，将看到如何编写顶点和片段函数，如何创建渲染管道状态对象，最后，如何编码使用此管道的绘图命令。</p><h2 id=自定义渲染管线如何处理数据>自定义渲染管线如何处理数据</h2><p>顶点函数会对每个顶点生成数据，片段函数会为图形上的片段生成数据，我们可以自定义其工作过程。配置管道的各个阶段时要记住一个目标，这意味着您知道希望管道生成什么以及它如何生成这些结果。</p><p>决定将什么数据传入你的渲染管线以及什么样的数据会在后续阶段通过渲染管线。总体上有三点需要你做的：</p><ol><li>管道的输入，由您的应用程序提供并传递到顶点阶段。</li><li>顶点阶段的输出，传递到光栅化阶段。</li><li>片段阶段的输入，由您的应用程序提供或由光栅化阶段生成。</li></ol><p>在本示例中，渲染管线的输入是顶点的位置坐标和颜色数据。输入坐标在自定义坐标空间中定义，以距视图中心的像素为单位。这些坐标需要转换为 Metal 的坐标系。</p><p>声明一个AAPLVertex结构体，使用 SIMD 矢量类型来保存位置和颜色数据。要共享一个关于结构在内存中的布局方式的定义，请在公共标头中声明结构并将其导入 Metal 着色器和应用程序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>typedef</span> <span class=kd>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector_float2</span> <span class=n>position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vector_float4</span> <span class=n>color</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>AAPLVertex</span><span class=p>;</span>
</span></span></code></pre></div><p>SIMD 类型在 Metal Shading Language 中很常见，您还应该使用 simd 库在您的应用程序中使用它们。SIMD 类型包含特定数据类型的多个通道，所以以vector_float（包含2个32位的float）格式声明坐标，颜色信息使用vector_float4进行存储，包含红、绿、蓝、透明度通道。</p><p>在应用程序中，输入数据使用常量数组指定：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>static</span> <span class=n>const</span> <span class=n>AAPLVertex</span> <span class=n>triangleVertices</span><span class=p>[]</span> <span class=p>=</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2D positions,    RGBA colors</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=p>{</span>  <span class=mi>250</span><span class=p>,</span>  <span class=o>-</span><span class=mi>250</span> <span class=p>},</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span> <span class=p>}</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=p>{</span> <span class=o>-</span><span class=mi>250</span><span class=p>,</span>  <span class=o>-</span><span class=mi>250</span> <span class=p>},</span> <span class=p>{</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span> <span class=p>}</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=p>{</span>    <span class=mi>0</span><span class=p>,</span>   <span class=mi>250</span> <span class=p>},</span> <span class=p>{</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span> <span class=p>}</span> <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>顶点阶段为顶点生成数据，因此它需要提供颜色和变换后的位置。 然后使用 SIMD 类型声明包含位置和颜色值的 RasterizerData 结构体。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>RasterizerData</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// The [[position]] attribute of this member indicates that this value</span>
</span></span><span class=line><span class=cl>    <span class=c1>// is the clip space position of the vertex when this structure is</span>
</span></span><span class=line><span class=cl>    <span class=c1>// returned from the vertex function.</span>
</span></span><span class=line><span class=cl>    <span class=n>float4</span> <span class=n>position</span> <span class=p>[[</span><span class=n>position</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Since this member does not have a special attribute, the rasterizer</span>
</span></span><span class=line><span class=cl>    <span class=c1>// interpolates its value with the values of the other triangle vertices</span>
</span></span><span class=line><span class=cl>    <span class=c1>// and then passes the interpolated value to the fragment shader for each</span>
</span></span><span class=line><span class=cl>    <span class=c1>// fragment in the triangle.</span>
</span></span><span class=line><span class=cl>    <span class=n>float4</span> <span class=n>color</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>输出的位置信息（下面详细描述）必须定义为vector_float4。 颜色在输入数据结构中被声明。</p><p>需要告诉 Metal 光栅化数据中的哪个字段提供位置数据，因为 Metal 不会对结构中的字段强制执行任何特定的命名约定。 使用 [[position]] 属性限定符注释位置字段以声明此字段包含输出位置。</p><p>片段函数只是将光栅化阶段的数据传递到后面的阶段，因此它不需要任何额外的参数。</p><h2 id=声明顶点函数>声明顶点函数</h2><p>声明顶点函数，包括它的输入参数和它输出的数据。 就像使用 kernel 关键字声明计算函数一样，您使用 vertex 关键字声明顶点函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>vertex</span> <span class=n>RasterizerData</span>
</span></span><span class=line><span class=cl><span class=n>vertexShader</span><span class=p>(</span><span class=n>uint</span> <span class=n>vertexID</span> <span class=p>[[</span><span class=n>vertex_id</span><span class=p>]],</span>
</span></span><span class=line><span class=cl>             <span class=n>constant</span> <span class=n>AAPLVertex</span> <span class=o>*</span><span class=n>vertices</span> <span class=p>[[</span><span class=n>buffer</span><span class=p>(</span><span class=n>AAPLVertexInputIndexVertices</span><span class=p>)]],</span>
</span></span><span class=line><span class=cl>             <span class=n>constant</span> <span class=n>vector_uint2</span> <span class=o>*</span><span class=n>viewportSizePointer</span> <span class=p>[[</span><span class=n>buffer</span><span class=p>(</span><span class=n>AAPLVertexInputIndexViewportSize</span><span class=p>)]])</span>
</span></span></code></pre></div><p>第一个参数 vertexID 使用 [[vertex_id]] 属性限定符，这是另一个 Metal 关键字。 当您执行渲染命令时，GPU 会多次调用您的顶点函数，为每个顶点生成一个唯一值。</p><p>第二个参数 vertices 是一个包含顶点数据的数组，使用之前定义的 AAPLVertex 结构。</p><p>要将位置转换为 Metal 的坐标，该函数需要绘制三角形的视口大小（以像素为单位），因此它存储在 viewportSizePointer 参数中。</p><p>第二个和第三个参数具有 [[buffer(n)]] 限定符。 默认情况下，Metal 会自动为每个参数分配参数表中的接收对象。 当您将 [[buffer(n)]] 限定符添加到缓冲区参数时，您会明确告诉 Metal 使用哪个接收对象。 显式声明可以更轻松地修改着色器，而无需更改应用程序代码。 在共享头文件中声明两个索引的常量。</p><p>这个函数会输出一个RasterizerData对象。</p><h2 id=编写顶点数据>编写顶点数据</h2><p>顶点函数必须包含输出结构体的两个字段，使用 vertexID 参数来索引顶点数组并读取顶点的输入数据。 此外，需要获取绘制图像视图的尺寸。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>float2</span> <span class=n>pixelSpacePosition</span> <span class=p>=</span> <span class=n>vertices</span><span class=p>[</span><span class=n>vertexID</span><span class=p>].</span><span class=n>position</span><span class=p>.</span><span class=n>xy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Get the viewport size and cast to float.</span>
</span></span><span class=line><span class=cl><span class=n>vector_float2</span> <span class=n>viewportSize</span> <span class=p>=</span> <span class=n>vector_float2</span><span class=p>(</span><span class=o>*</span><span class=n>viewportSizePointer</span><span class=p>);</span>
</span></span></code></pre></div><p>顶点函数必须提供空间坐标中的位置数据，这些坐标是使用四维齐次向量 (x,y,z,w) 指定的 3D 点。光栅化阶段获取输出位置并将 x、y 和 z 坐标除以 w，以在归一化设备坐标中生成 3D 点。 归一化设备坐标与视口大小无关。</p><p><img src=/img/0918/positions.png alt=空间坐标></p><p>归一化坐标使用左手坐标系（opengl为右手）并映射到视图上的坐标系；在此坐标系中裁切出一个框，包裹住需要绘制的图形，进而进行光栅化；裁切框的左下角位于x-y坐标系上，坐标为（-1.0，-1.0），右上角位于（1.0,1.0）。z轴的正值指向远离摄像机的方向（远离屏幕），z轴的可见范围为0.0～1.0之间。</p><p><img src=/img/0918/transform_coordinates.png alt=变换坐标></p><p>因为这是一个 2D 的应用程序，因此不需要齐次坐标，首先会将默认值写入输出坐标，其中 w 值设置为 1.0，其他坐标设置为 0.0。这意味着顶点坐标已经归一化在空间坐标中，同时顶点函数会在这个坐标空间之中，生成对应的（x，y）坐标。将输入位置除以视口大小的一半以生成标准化设备坐标。 由于此计算是使用 SIMD 类型执行的，因此可以使用一行代码同时划分两个通道。 执行除法并将结果放在输出位置的 x 和 y 通道中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>out</span><span class=p>.</span><span class=n>position</span> <span class=p>=</span> <span class=n>vector_float4</span><span class=p>(</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>out</span><span class=p>.</span><span class=n>position</span><span class=p>.</span><span class=n>xy</span> <span class=p>=</span> <span class=n>pixelSpacePosition</span> <span class=o>/</span> <span class=p>(</span><span class=n>viewportSize</span> <span class=o>/</span> <span class=mf>2.0</span><span class=p>);</span>
</span></span></code></pre></div><p>最后将颜色信息赋值给输出的color字段：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>out</span><span class=p>.</span><span class=n>color</span> <span class=p>=</span> <span class=n>vertices</span><span class=p>[</span><span class=n>vertexID</span><span class=p>].</span><span class=n>color</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=编写片段函数>编写片段函数</h2><p>渲染目标的片段（fargment）是可通过着色器配置的，光栅化会确定渲染目标的哪些像素被图元覆盖。 只有像素中心在三角形内的片段才会被渲染。</p><p><img src=/img/0918/fragment.png alt=片段渲染></p><p>片段函数处理来自光栅器的单个位置的传入信息，并计算每个渲染目标的输出值。 这些片段值由渲染管线中的后续阶段处理，并最终被写入渲染目标。</p><p>片段可更改的原因是因为片段阶段之后的渲染管线可以配置为拒绝某些片段或更改写入渲染目标的内容。 在此示例中，片段阶段计算的所有值都按原样写入渲染目标。</p><p>此示例中的片段着色器接收参数与顶点着色器输出参数相同。使用 fragment 关键字声明片段函数。它只有一个参数，即顶点阶段提供的RasterizerData 结构体。添加 [[stage_in]] 属性限定符以指示此参数由光栅器生成。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>fragment</span> <span class=n>float4</span> <span class=n>fragmentShader</span><span class=p>(</span><span class=n>RasterizerData</span> <span class=k>in</span> <span class=p>[[</span><span class=n>stage_in</span><span class=p>]])</span>
</span></span></code></pre></div><p>如果您的片段函数对应多个渲染目标，它必须为每个渲染目标声明一个结构体。 因为这个示例只有一个渲染目标，所以您直接指定一个浮点向量作为函数的输出。 此输出是要写入渲染目标的颜色。</p><p>光栅化阶段计算每个片段参数的值并使用它们调用片段函数。 光栅化阶段将其颜色参数计算为三角形顶点处颜色的混合。 片段离顶点越近，顶点颜色对最终颜色的影响就越大。</p><p><img src=/img/0918/fragment_color.png alt=片段着色></p><p>片段函数会返回插值颜色作为函数的输出。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=k>return</span> <span class=k>in</span><span class=p>.</span><span class=n>color</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=创建渲染管线状态对象>创建渲染管线状态对象</h2><p>现在顶点和片段函数已经完成，还需要通过创建一个渲染管线来完成调用，首先，获取默认库，并为每个函数获取一个 MTLFunction 对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>id</span><span class=p>&lt;</span><span class=n>MTLLibrary</span><span class=p>&gt;</span> <span class=n>defaultLibrary</span> <span class=p>=</span> <span class=p>[</span><span class=n>_device</span> <span class=n>newDefaultLibrary</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=p>&lt;</span><span class=n>MTLFunction</span><span class=p>&gt;</span> <span class=n>vertexFunction</span> <span class=p>=</span> <span class=p>[</span><span class=n>defaultLibrary</span> <span class=n>newFunctionWithName</span><span class=p>:@</span><span class=s>&#34;vertexShader&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=p>&lt;</span><span class=n>MTLFunction</span><span class=p>&gt;</span> <span class=n>fragmentFunction</span> <span class=p>=</span> <span class=p>[</span><span class=n>defaultLibrary</span> <span class=n>newFunctionWithName</span><span class=p>:@</span><span class=s>&#34;fragmentShader&#34;</span><span class=p>];</span>
</span></span></code></pre></div><p>接下来，创建一个 MTLRenderPipelineState 对象。渲染管道还有很多属性要配置，因此使用 MTLRenderPipelineDescriptor 来配置管线。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>MTLRenderPipelineDescriptor</span> <span class=o>*</span><span class=n>pipelineStateDescriptor</span> <span class=p>=</span> <span class=p>[[</span><span class=n>MTLRenderPipelineDescriptor</span> <span class=n>alloc</span><span class=p>]</span> <span class=kd>init</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>pipelineStateDescriptor</span><span class=p>.</span><span class=n>label</span> <span class=p>=</span> <span class=p>@</span><span class=s>&#34;Simple Pipeline&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pipelineStateDescriptor</span><span class=p>.</span><span class=n>vertexFunction</span> <span class=p>=</span> <span class=n>vertexFunction</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pipelineStateDescriptor</span><span class=p>.</span><span class=n>fragmentFunction</span> <span class=p>=</span> <span class=n>fragmentFunction</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pipelineStateDescriptor</span><span class=p>.</span><span class=n>colorAttachments</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>pixelFormat</span> <span class=p>=</span> <span class=n>mtkView</span><span class=p>.</span><span class=n>colorPixelFormat</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>_pipelineState</span> <span class=p>=</span> <span class=p>[</span><span class=n>_device</span> <span class=n>newRenderPipelineStateWithDescriptor</span><span class=p>:</span><span class=n>pipelineStateDescriptor</span>
</span></span><span class=line><span class=cl>                                                         <span class=n>error</span><span class=p>:&amp;</span><span class=n>error</span><span class=p>];</span>
</span></span></code></pre></div><p>除了指定顶点和片段函数之外，还声明了管道将绘制到的所有渲染目标的像素格式。像素格式 (MTLPixelFormat) 定义了像素数据的内存布局。 一般而言，定义包括每个像素的字节数、存储在像素中的数据通道数以及这些通道的位布局。 由于此示例只有一个渲染目标并且由视图提供，因此将视图的像素格式复制到渲染管道描述符中。 您的渲染管道状态必须使用与渲染通道指定的像素格式兼容的像素格式。 在这个示例中，渲染通道和管道状态对象都使用视图的像素格式，因此它们始终相同。</p><p>当 Metal 创建渲染管线状态对象时，会为将片段函数的输出转换为渲染目标的像素格式。 如果要针对不同的像素格式，则需要创建不同的管道状态对象。 您可以在针对不同像素格式的多个管道中重复使用相同的着色器。</p><h2 id=设置视窗>设置视窗</h2><p>现在您已经有了管道的渲染管道状态对象，您将渲染三角形。 您可以使用渲染器执行此操作。 首先，设置视口，以通知 Metal 要绘制到渲染目标的哪个部分。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=c1>// Set the region of the drawable to draw into.</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>renderEncoder</span> <span class=n>setViewport</span><span class=p>:(</span><span class=n>MTLViewport</span><span class=p>){</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=n>_viewportSize</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>_viewportSize</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span> <span class=p>}];</span>
</span></span></code></pre></div><h2 id=设置渲染管线状态>设置渲染管线状态</h2><p>通过管线配置您需要使用的渲染管线状态：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=p>[</span><span class=n>renderEncoder</span> <span class=n>setRenderPipelineState</span><span class=p>:</span><span class=n>_pipelineState</span><span class=p>];</span>
</span></span></code></pre></div><h2 id=向顶点函数发送参数>向顶点函数发送参数</h2><p>通常需要使用缓冲区 (MTLBuffer) 将数据传递给着色器。 但是当只需要将少量数据发送给顶点函数时，就像例程中一样，可将数据直接复制到命令缓冲区中。</p><p>在示例中，将两个参数直接复制到命令缓冲区中。 顶点数据是从样本中定义的数组复制而来的。 视口数据是从您用于设置视口的同一变量复制而来的。</p><p>同时，片段函数只将光栅化后的输出结果作为输入，所以没有参数需要配置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=p>[</span><span class=n>renderEncoder</span> <span class=n>setVertexBytes</span><span class=p>:</span><span class=n>triangleVertices</span>
</span></span><span class=line><span class=cl>                       <span class=n>length</span><span class=p>:</span><span class=bp>sizeof</span><span class=p>(</span><span class=n>triangleVertices</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                      <span class=n>atIndex</span><span class=p>:</span><span class=n>AAPLVertexInputIndexVertices</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>renderEncoder</span> <span class=n>setVertexBytes</span><span class=p>:&amp;</span><span class=n>_viewportSize</span>
</span></span><span class=line><span class=cl>                       <span class=n>length</span><span class=p>:</span><span class=bp>sizeof</span><span class=p>(</span><span class=n>_viewportSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                      <span class=n>atIndex</span><span class=p>:</span><span class=n>AAPLVertexInputIndexViewportSize</span><span class=p>];</span>
</span></span></code></pre></div><h2 id=编写绘制命令>编写绘制命令</h2><p>指定基本类型、起始索引和顶点数。 渲染三角形时，调用顶点函数，其 vertexID 参数的值为 0、1 和 2。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=c1>// Draw the triangle.</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>renderEncoder</span> <span class=n>drawPrimitives</span><span class=p>:</span><span class=n>MTLPrimitiveTypeTriangle</span>
</span></span><span class=line><span class=cl>                  <span class=n>vertexStart</span><span class=p>:</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>                  <span class=n>vertexCount</span><span class=p>:</span><span class=mi>3</span><span class=p>];</span>
</span></span></code></pre></div><p>与使用 Metal 绘制到屏幕一样，您结束编码过程并提交命令缓冲区。 但是，您可以使用同一组步骤对更多渲染命令进行编码。 最终图像的渲染就像命令按照指定的顺序处理一样。 （出于性能考虑，GPU 可以并行处理命令甚至部分命令，只要最终结果看起来已经按顺序呈现即可。）</p><h2 id=颜色插值的实验>颜色插值的实验</h2><p>在此示例中，颜色会在三角形中插值。 这通常是您想要的，但有时您希望由一个顶点生成一个值并在整个图元中保持不变。 在顶点函数的输出上指定平面属性限定符以执行此操作。 现在试试这个。 在示例项目中找到 RasterizerData 的定义，并将 [[flat]] 限定符添加到其颜色字段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>float4</span> <span class=n>color</span> <span class=p>[[</span><span class=n>flat</span><span class=p>]];</span>
</span></span></code></pre></div><p>再次运行示例。 渲染管道在整个三角形中统一使用第一个顶点（称为激发顶点）的颜色值，并忽略其他两个顶点的颜色。 您可以混合使用平面着色值和插值值，只需在顶点函数的输出上添加或省略平面限定符即可。 Metal 着色器语言规范定义了其他属性限定符，您也可以使用它来修改光栅化行为。</p><div class=blog-tags><a href=https://ingslh.com/tags/metal/>Metal</a>&nbsp;</div><h4 class=see-also>See also</h4><ul><li><a href=/post/2022-09-08-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-2/>Apple Metal文档（2）：使用Metal绘制视图内容</a></li><li><a href=/post/2022-09-01-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-1/>Apple Metal文档（1）：在GPU上进行计算</a></li></ul></article><ul class="pager blog-pager"><li class=previous><a href=https://ingslh.com/post/2022-09-08-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-2/ data-toggle=tooltip data-placement=top title="Apple Metal文档（2）：使用Metal绘制视图内容">&larr; Previous Post</a></li><li class=next><a href=https://ingslh.com/post/2023-02-23-r2grap%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D1%E8%AE%BE%E8%AE%A1%E7%AF%87/ data-toggle=tooltip data-placement=top title=R2grap项目介绍(1):总述与结构篇>Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//ingslh-com.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:ingslh@foxmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/ingslh title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/Ingslh_lzh title=Twitter><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=ingslh.github.io>ingslh</a>
&nbsp;&bull;&nbsp;&copy;
2023
&nbsp;&bull;&nbsp;
<a href=https://ingslh.com>Ingslh's Blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.111.1</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div><div class=footer_custom><div class=container><p class="copyright text-muted"><a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/><i class="fab fa-creative-commons fa-lg"></i>
<i class="fab fa-creative-commons-by fa-lg"></i>
<i class="fab fa-creative-commons-sa fa-lg"></i></a> &nbsp;
This work is licensed under a
<a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/>Creative
Commons Attribution-ShareAlike 4.0 International License</a>.</p></div></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous></script>
<script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script>
<script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script>
<script src=https://ingslh.com/js/main.js></script>
<script src=https://ingslh.com/js/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script><script>$(document).ready(function(){$("pre.chroma").css("padding","0")})</script><script>renderMathInElement(document.body)</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://ingslh.com/js/load-photoswipe.js></script></body></html>