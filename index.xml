<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ingslh's Blog</title><link>https://ingslh.com/</link><description>Recent content on Ingslh's Blog</description><generator>Hugo -- gohugo.io</generator><managingEditor>ingslh@foxmail.com (ingslh)</managingEditor><webMaster>ingslh@foxmail.com (ingslh)</webMaster><lastBuildDate>Thu, 01 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ingslh.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Apple Metal文档（1）：在GPU上进行计算</title><link>https://ingslh.com/post/2022-09-01-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-1/</link><pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-09-01-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-1/</guid><description>&lt;blockquote>
&lt;p>本文翻译自苹果Metal的官方文档：Performing Calculations on a GPU，如果哪里翻译有误，请大家指出，我会及时更正。谢谢！&lt;/p>
&lt;/blockquote>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>在这个例程中，你将学习到在所有Metal程序中所用到的基本任务。你将看到如何把一个简单的c语言程序转换成Metal着色器语言（MSL），并使其能够在GPU上运行。你会找到一个GPU，通过创建管线准备使MSL函数在GPU上运行，并构造GPU能够访问的数据对象。针对你的数据对象去运行管线，首先创建一个命令缓存区，将命令写入其中，然后将缓存区提交到命令队列，最后Metal将命令发送到GPU，并执行它们。&lt;/p>
&lt;h2 id="编写一个gpu函数来执行计算">编写一个GPU函数来执行计算&lt;/h2>
&lt;p>为讲解GPU编程，给出一个两数组对应位求和，并把结果放进第三个数组的示例程序。示例1为在cpu上运行上述运算的C程序，通过遍历索引index，在每次循环中计算result。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">add_arrays&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于每一次计算是相对独立的，因此这两个数组每一位上的求和是可以同步进行的。为了能够在GPU上运行这个程序，需要将这个函数重写成Metal的着色器语言（MSL）。MSL为GPU编程而设计的c++变体。其中，运行在GPU的代码被称为着色器（shader），这是由于这类GPU程序曾首先被应用于计算3D图像中的颜色。示例2展示了与示例1进行同样运算的MSL shader。在官方给出的示例代码中，这个函数定义在add.metal。使用Xcode构建并创建一个默认的Metal库，它会被嵌入到应用程序中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">kernel&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add_arrays&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">device&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">device&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uint&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">thread_position_in_grid&lt;/span>&lt;span class="p">]])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// the for-loop is replaced with a collection of threads, each of which
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// calls this function.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>示例2与示例1相似，当在MSL版本中，有一些重要的区别。仔细观察示例2.&lt;/p>
&lt;p>首先，这个函数加了一个kernel关键字，使这个函数被声明为：&lt;/p>
&lt;ol>
&lt;li>公共（public）GPU函数，程序在调用这个Metal库时，public是仅可见的函数，同时public函数不能被其他shader程序调用。&lt;/li>
&lt;li>计算函数（也称为计算kernel），它通过线程网格（gird）完成并行计算。&lt;/li>
&lt;/ol>
&lt;p>如需了解其他用于声明public图形函数的关键字，请参阅&lt;a href="https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives">使用渲染管道渲染图元&lt;/a>。&lt;/p>
&lt;p>add_arrays 函数用 device 关键字声明了它的三个参数，这表示这些数组指针位于Device地址空间中。MSL定义了若干不相邻的内存区域，每当在MSL中声明一个指针，必须使用一个关键字来声明它的内存地址。使用device修饰的地址空间，代表GPU可以对其进行持续的读写。&lt;/p>
&lt;p>示例2移除了示例1的for循环，因为是被gird中的多线程调用的，这个示例创建了一个与数组维度一致的一维线程网格，因此数组中每一个数值求和是不同线程完成计算的。&lt;/p>
&lt;p>同时示例2使用了一个新的index索引变量替代之前在for循环中的索引，index通过c++的&lt;a href="https://en.cppreference.com/w/cpp/language/attributes">attribute&lt;/a>被赋值为另一个MSL关键词：&lt;em>thread_position_in_grid&lt;/em>，这个关键字表明 Metal 会为每个线程计算一个唯一的索引，并将索引传递给变量。因为add_arrays使用了一维gird，因此index定义为整数（uint）。尽管for循环被移除，示例1和示例2使用相同的方式完成求和。如果想将类似的代码从c/c++转换为MSL，可以使用相同的方式循环逻辑的替换。&lt;/p>
&lt;h2 id="检索gpu">检索GPU&lt;/h2>
&lt;p>在应用程序中，&lt;strong>MTLDevice&lt;/strong>代表一个GPU的简单抽象（Metal设备对象），可通过它完成与GPU的通信。Metal为每一个GPU创建一个MTLDevice，并可通过调用MTLCreateSystemDefaultDevice()获取默认的设备对象。在 macOS 中，Mac 可以有多个 GPU，Metal 会选择其中一个 GPU 作为默认值并返回该 GPU 的MTLDevice，Metal也提供了用于检索所有GPU的其他API，但此示例仅使用默认值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLDevice&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">device&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MTLCreateSystemDefaultDevice&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="初始化metal对象">初始化Metal对象&lt;/h2>
&lt;p>Metal将其他与GPU相关的工作（如编译shader、内存缓存区、图像纹理）表示为不同对象。要创建这些特定的GPU对象。可以通过调用MTLDevice和派生于MTLDevice对象的方法创建这些特定的GPU对象。由GPU的MTLDevice对象直接或间接创建的所有对象仅可用于对应的GPU，对于使用多个GPU的应用程序，Metal会创建多个GPU对象，并为每个对象创建类似的Metal层次结构。&lt;/p>
&lt;p>示例程序中使用一个自定义的类MetalAdder来管理需要与GPU进行通信的对象，在类的初始化中会创建这些对象，并存储在其属性中。在程序中会创建一个该类的示例，传入用于创建辅助对象的 Metal 设备对象。这个MetalAdder对象会在生命周期内保持对Metal对象的强引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">MetalAdder&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">adder&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">MetalAdder&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">initWithDevice&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在Metal中，高消耗的初始化任务可以一次运行之后，将结果保留并在低消耗情况下被使用。很少情况下需要在性能要求严格的代码中执行此类任务。&lt;/p></description></item><item><title>MVC MVP MVVM架构浅析</title><link>https://ingslh.com/post/2022-06-18-mvc-mvp-mvvm%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</link><pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-06-18-mvc-mvp-mvvm%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</guid><description>&lt;p>&lt;strong>MVC&lt;/strong>、&lt;strong>MVP&lt;/strong>和&lt;strong>MVVM&lt;/strong>是三种用以实现软件系统中用户界面与逻辑层解耦的抽象架构模型，其中后两种算是&lt;strong>MVC&lt;/strong>的变形。作为三种最常用的三种架构设计模式，它们有着各自不同的的应用场景，结合自己之前的经验，来简单总结下它们的特点。&lt;/p>
&lt;p>&lt;em>在实际开发中，选用的架构可以看作是一种骨架，结合业务需求往往需要在骨架的基础上进行一些改造并丰富细节。&lt;/em>&lt;/p>
&lt;h2 id="mvc">MVC&lt;/h2>
&lt;p>MVC（Model-View-Controller）模式主要分为三个部分，分别是模型、视图和控制器。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mvc.png" alt="MVC结构图">&lt;/p>
&lt;ul>
&lt;li>模型（Model）：处理底层业务逻辑，实现相关运算；&lt;/li>
&lt;li>视图（View）：页面显示，完成与用户的交互；&lt;/li>
&lt;li>控制器（Controller）：完成模型与视图的数据（或命令）通信，完成应用层面的相关任务；&lt;/li>
&lt;/ul>
&lt;p>从上图的通信流程图来看，三个模块间的通信是单向的，首先用户操作视图，传达相应的指令到控制器，控制器将指令解析，传递给模型进行相应的处理，如果需要将结果反馈给视图，则再将指令传递给视图，最终视图完成更新。&lt;/p>
&lt;h2 id="mvp">MVP&lt;/h2>
&lt;p>MVP(Model-View-Presenter)是从经典的MVC演变过来的，但是由于model和view之间不进行直接连接，而是将presenter作为桥梁，完成从view到model到数据传输，以及从model到view到界面更新。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mvp.png" alt="MVP结构图">&lt;/p>
&lt;p>它的特点总结是：&lt;/p>
&lt;ul>
&lt;li>各部分之间的通信，是双向的；&lt;/li>
&lt;li>Presenter就是相对于MVC中的Controller，为了便于区分，将控制器命名为Presenter；&lt;/li>
&lt;li>Presenter可以对应多个view，控制接口后，能应对来自于view的复杂变化；&lt;/li>
&lt;/ul>
&lt;p>从结构上来看，mvp中因为view与model不直接通信，降低了整个系统的耦合程度，相比较mvc来说，view由于只被动地处理界面，因此被称为“被动视图”（Passive View），随之而来造成presenter的变重，除了要完成整个业务逻辑的实现，还要加上对view的控制。&lt;/p>
&lt;h2 id="mvvm">MVVM&lt;/h2>
&lt;p>MVVM（Model-View-ViewModel），最大的区别是将控制器（controller/presenter）换成了ViewModel（VM），与之对应的VM在功能方面，也进行了更新。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mvvm.png" alt="MVVM结构图">&lt;/p>
&lt;p>从结构图来看，与MVP的变化不大，但对于VM来说，它与model采用双向绑定（data-binding）的形式，即如果View和ViewModel任意一方发生变化时，另一方会自动更新。&lt;/p>
&lt;h2 id="在多视图下的应用">在多视图下的应用&lt;/h2>
&lt;p>考虑一种“&lt;strong>复杂软件&lt;/strong>”的情况，即主视图（parent-view）下存在着多个子视图（child-view），每个视图之间的业务逻辑各不相同，但从界面的角度来说又各自关联，如何套用到上述的三种模型中呢？&lt;/p>
&lt;p>以&lt;strong>MVP&lt;/strong>模型举例，当然可以把多个视图抽象成一个整体，这样看就与前面的流程图差不多，但从模型和presenter的角度来说，它们会变得很臃肿且耦合度高（在presenter/model下，将所有view对应的指令和实现放在一起）。&lt;/p>
&lt;p>在尽可能低耦合的目标下，可以针对每一个view，构建对应的model和presenter，其中presenter不单要完成模块内（与自身model和view）的指令传递，也要完成与其他模块（其他presenter）的通信，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mulit-view.png" alt="多视图下的应用">&lt;/p>
&lt;p>如果这个&lt;strong>复杂软件&lt;/strong>需要多个开发人员协作时，只要把presenter间的接口确定好，每个开发人员可以最大程度上专注于自己所负责模块的功能实现。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>最后以一句老生常谈的话作为总结：&lt;/p>
&lt;blockquote>
&lt;p>适用于任何情况的架构设计模型是不存在的，只能在结合实际需求的情况下寻找或创造一种&lt;strong>相对&lt;/strong>适合的模型。&lt;/p>
&lt;/blockquote>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://henleylee.github.io/posts/2019/de9d67a4.html">MVC、MVP 和 MVVM 之间的区别&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">MVC，MVP 和 MVVM 的图示&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/6901200799242649607">正确认识 MVC/MVP/MVVM&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Hugo + Github Pages搭站记录</title><link>https://ingslh.com/post/2022-06-10-hugo+githubpages%E6%90%AD%E7%AB%99%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-06-10-hugo+githubpages%E6%90%AD%E7%AB%99%E8%AE%B0%E5%BD%95/</guid><description>&lt;p>伴随Web技术的蓬勃发展，使得构建静态网站的成本越来越低，这个博客是通过Hugo和GitHub Pages完成的构建，作为博客的第一篇文章，主要介绍下这个博客的搭建过程，虽然现在网上相关的资料已经非常丰富，但是我在建站的过程中还是遇到了很多问题，抱着分享与总结的目的，在这里记录下我的实现流程供大家参考。🌟&lt;/p>
&lt;h3 id="文中所使用的软件版本">文中所使用的软件版本&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Version&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Hugo&lt;/td>
&lt;td>0.98&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Git&lt;/td>
&lt;td>2.36&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>如果需要编译Hugo源码,需要Go1.3+&lt;/em>&lt;/p>
&lt;h3 id="简述">简述&lt;/h3>
&lt;p>在github上建立两个仓库，一个作为&lt;strong>源码仓库&lt;/strong>(&lt;em>user.github.io.src&lt;/em>)，另一个作为用于&lt;strong>主页仓库&lt;/strong>(&lt;em>user.git.io&lt;/em>)。将主页仓库作为源码仓库的子模块，利用Github Actions，使源码repo在push时将编译结果输出到主页repo中，然后页面repo利用GitHub Pages渲染实现一个博客站点。一般将源码repo设为私有库，同时并不影响主页repo里的页面展示。&lt;/p>
&lt;blockquote>
&lt;p>与此同时，还有两种实现方式：一种是使用Hugo创建的site主目录作为Github Pages的运行根，还有一种是使用hugo编译后的publishDir作为Github Pages的运行根。两种方式都能够渲染出页面，但也都有各自的问题：第一种方式会暴露你的相关信息，例如配置文件下的个人信息，未发表的草稿等等都会展示在github上；第二种方式由于没有git仓库建立在你的源码目录上，因此不能进行有效的版本管理，维护起来会很麻烦。&lt;/p>
&lt;/blockquote>
&lt;h2 id="主要流程">主要流程&lt;/h2>
&lt;h3 id="1安装hugo和git">1.安装hugo和git&lt;/h3>
&lt;p>hugo和git都可通过官网上的指南进行安装，&lt;a href="https://gohugo.io/getting-started/installing/">Install Hugo｜Hugo&lt;/a> 和&lt;a href="https://git-scm.com/downloads">Git-Downloads&lt;/a>;&lt;/p>
&lt;p>在终端输入&lt;code>hugo version&lt;/code>和&lt;code>git version&lt;/code>验证是否安装成功。&lt;/p>
&lt;h3 id="2创建github仓库">2.创建Github仓库&lt;/h3>
&lt;p>创建如下图所示的两个&lt;strong>空&lt;/strong>仓库，其中将用户名替换成自己的，源码仓库（&lt;em>user.github.io.src&lt;/em>）命名可以任意，但是为了便于区分，加上了后缀 &lt;strong>.src&lt;/strong>。
&lt;img src="https://ingslh.com/img/github_repo.jpeg" alt="">&lt;/p>
&lt;h3 id="3新建hugo网站">3.新建Hugo网站&lt;/h3>
&lt;p>通过终端将源码库（&lt;em>user.github.io.src&lt;/em>）clone到本地，进入该文件夹，使用&lt;code>hugo new&lt;/code>创建Hugo网站&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git clone https://github.com/user/user.github.io.src.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> user.github.io.src
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">hugo new site . --force
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这里没有现在本地创建git仓库的原因是，新建本地仓库的默认分支为&lt;code>master&lt;/code>，而github上新建仓库的默认分支为&lt;code>main&lt;/code>，连接远程仓库的时候，要再建一个&lt;code>main&lt;/code>分支，并把&lt;code>master&lt;/code>分支删去。&lt;/p>
&lt;/blockquote>
&lt;h3 id="4添加主题">4.添加主题&lt;/h3>
&lt;p>需要为新建的site选择一个合适的主题，可以在&lt;a href="https://themes.gohugo.io">Hugo Themes&lt;/a>挑选一个自己喜欢的，在挑选主题时，建议先看下所用主题的README，下面就以本站使用的&lt;strong>BeautifulHugo&lt;/strong>举例；&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ mkdir themes &lt;span class="c1">#在源码repo的根目录下执行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ &lt;span class="nb">cd&lt;/span> themes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git submodule add https://github.com/halogenica/beautifulhugo.git beautifulhugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样&lt;code>themes&lt;/code>的文件夹下会有&lt;code>beautifulhugo&lt;/code>的主题了，由于是建立的新hugo工程，可以根据&lt;code>exampleSite&lt;/code>下的&lt;code>config.toml&lt;/code>修改自己的主目录下的&lt;code>config.toml&lt;/code>，&lt;strong>建议直接拷贝过去，再修改上自己的一些信息。&lt;/strong>&lt;/p>
&lt;p>一开始也可以把&lt;code>exampleSite&lt;/code>下的&lt;code>content&lt;/code>文件夹复制到主目录进行覆盖。&lt;/p>
&lt;blockquote>
&lt;p>一般&lt;code>exampleSite&lt;/code>会有&lt;code>content&lt;/code>、&lt;code>layouts&lt;/code>、&lt;code>static&lt;/code>文件夹，可以根据自己需要把它们拷贝到主目录下。&lt;/p>
&lt;/blockquote>
&lt;p>然后就可以通过hugo的&lt;code>server&lt;/code>命令，预览主题效果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ hugo server &lt;span class="c1">#如果希望显示草稿（draft）可以加上 —D&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当返回信息包含如下时，可进入&lt;a href="http://localhost:1313/">http://localhost:1313/&lt;/a>进行预览。&lt;/p>
&lt;blockquote>
&lt;p>如果效果异常，大概率是配置文件（config.toml）修改得不正确。请参照所使用主题的README和Hugo的官方文档进行检查。&lt;/p>
&lt;/blockquote>
&lt;h3 id="5配置token">5.配置token&lt;/h3>
&lt;p>下面需要为Github Actions的自动部署配置token，配置方法如下：&lt;/p>
&lt;p>首先通过github生成token，在你的github主页下点击头像框，依次进入&lt;strong>Setting-&amp;gt;Developer Settings-&amp;gt;Personal access tokens&lt;/strong>&lt;/p>
&lt;p>选择Generate new token，按规则填入note和expiration，其中expiration可以尽量填大一些，避免后续需要频繁更新。&lt;/p>
&lt;p>勾选下面的&lt;code>repo&lt;/code>和&lt;code>admin:repo_hook&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/token_config.png" alt="配置token">&lt;/p>
&lt;p>点击&lt;code>Generate token&lt;/code>进行生成，并复制token。&lt;/p>
&lt;p>生成后需要在源码repo中添加新生成的token，在github的源码repo中通过Settings-&amp;gt;Secrets-&amp;gt;Actions进入，填写Name和Value，其中Name可以自己定义（我定义的是ACTION_ACCESS_TOKEN，后续配置workflow会用到），Value中填入之前复制的token。&lt;/p>
&lt;blockquote>
&lt;p>实现Actions的自动部署还有一种方式是关联源码repo和页面repo的ssh key，过程会相对繁琐些，且在实际配置后，push源码repo时，Actions会报错&lt;code>Action failed with &amp;quot;The process '/usr/bin/ssh-add' failed with exit code 1&amp;quot;&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h3 id="6设置workflow">6.设置workflow&lt;/h3>
&lt;p>生成token后，在源码仓库的Actions中新建一个workflow，根据&lt;a href="https://github.com/peaceiris/actions-hugo#getting-started">Github Actions for Hugo&lt;/a>进行填写，我的workflow.yml如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy Hugo Site to Github Pages on Main Branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">push&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">branches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build-deploy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-18.04&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v1 &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># v2 does not have submodules option now&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">submodules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">fetch-depth&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch all history for .GitInfo and .Lastmod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Setup Hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-hugo@v2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#hugo官方提供的action，用于在任务环境中获取hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">hugo-version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;latest&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># extended: true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Build&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hugo --minify&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#构建静态网页，默认存在publish文件夹下&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-gh-pages@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">personal_token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.ACTION_ACCESS_TOKEN }}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># ACTION_ACCESS_TOKEN修改成之前填写secret的名字&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">external_repository&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">username/ingslh.github.io&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Pages远程仓库,更换username &lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_dir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#默认发布public文件夹里的内容&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">keep_files&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># remove existing files&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_branch&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># deploying branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">commit_message&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ github.event.head_commit.message }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>commit后该yml会生成在repo的./github/worksflows下。&lt;/p>
&lt;h3 id="7自动部署发布">7.自动部署发布&lt;/h3>
&lt;p>在本地的源码仓库的根目录下中提交修改到远程库，actions会自动帮你把hugo编译的静态页面推送到页面repo中，完成部署。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git add .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s2">&amp;#34;commit info&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git pull --rebase &lt;span class="c1">#由于远程库更新了workflow文件，所以需要pull下&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回到github的源码repo中，点击Actions，查看自动部署是否成功，如果成功部署会出现如下结果：
&lt;img src="https://ingslh.com/img/actions_success.png" alt="部署成功">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>至此已完成了通过Hugo+Github pages对个人博客的搭建，其实对于初始博客还有很多地方可以优化，比如加入评论系统，加入暗色模式，对多语言的支持等等，之后的更新也同样会进行记录。😄&lt;/p></description></item><item><title>About me</title><link>https://ingslh.com/page/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/page/about/</guid><description>&lt;p>😄Hi！欢迎来到我的博客，我是ingslh，一名c/c++程序员，平时主要做一些音视频开发、图形图像渲染的工作，目前坐标长沙。&lt;/p>
&lt;p>一些爱好：&lt;/p>
&lt;ul>
&lt;li>🎵：后朋(&lt;em>PostPunk&lt;/em>)、放克(&lt;em>Funk&lt;/em>);&lt;/li>
&lt;li>🎮：杀戮尖塔（&lt;em>Slay the Spire&lt;/em>）、极乐迪斯科(&lt;em>Disco Elysium&lt;/em>);&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;em>不太好写，随便写一些近期的&lt;/em>🤔&lt;/p>
&lt;/blockquote>
&lt;p>关于职场身份，理想是成为一名独立开发者，希望有生之年能实现吧。&lt;/p>
&lt;p>建立这个博客的目的是记录我在工作和平时折腾的过程中遇到的一些问题与解决这些问题的收获。&lt;/p>
&lt;p>最后想分享下吴军博士提出的工程师的“五个等级”：&lt;/p>
&lt;ul>
&lt;li>5.能独立解决问题，完成工程工作；&lt;/li>
&lt;li>4.指导和带领其他人一起完成更有影响力的工作；&lt;/li>
&lt;li>3.独立设计和实现产品，并在市场上成功；&lt;/li>
&lt;li>2.设计和实现别人不能做的产品；&lt;/li>
&lt;li>1.开创一个产业；&lt;/li>
&lt;/ul>
&lt;p>&lt;em>自评下，我应该5还没有达到&lt;/em> :(&lt;/p></description></item></channel></rss>