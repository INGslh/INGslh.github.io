<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ingslh's Blog</title><link>https://ingslh.com/</link><description>Recent content on Ingslh's Blog</description><generator>Hugo -- gohugo.io</generator><managingEditor>ingslh@foxmail.com (ingslh)</managingEditor><webMaster>ingslh@foxmail.com (ingslh)</webMaster><lastBuildDate>Sun, 04 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ingslh.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Apple Metal文档（1）：在GPU上进行计算</title><link>https://ingslh.com/post/2022-09-01-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-1/</link><pubDate>Sun, 04 Sep 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-09-01-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-1/</guid><description>&lt;blockquote>
&lt;p>本文翻译自苹果Metal的官方文档：&lt;a href="https://developer.apple.com/documentation/metal/performing_calculations_on_a_gpu">Performing Calculations on a GPU&lt;/a>，如果哪里翻译有误，请大家指出，我会及时更正。欢迎转载，但禁止用于商业用途。谢谢！&lt;/p>
&lt;/blockquote>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>在这个例程中，你将学习到在所有Metal程序中所用到的基本任务。你将看到如何把一个简单的c语言程序转换成Metal着色器语言（MSL），并使其能够在GPU上运行。你会找到一个GPU，通过创建管线准备使MSL函数在GPU上运行，并构造GPU能够访问的数据对象。针对你的数据对象去运行管线，首先创建一个命令缓存区，将命令写入其中，然后将缓存区提交到命令队列，最后Metal将命令发送到GPU，并执行它们。&lt;/p>
&lt;h2 id="编写一个gpu函数来执行计算">编写一个GPU函数来执行计算&lt;/h2>
&lt;p>为讲解GPU编程，给出一个两数组对应位求和，并把结果放进第三个数组的示例程序。示例1为在cpu上运行上述运算的C程序，通过遍历索引index，在每次循环中计算result。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">add_arrays&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于每一次计算是相对独立的，因此这两个数组每一位上的求和是可以同步进行的。为了能够在GPU上运行这个程序，需要将这个函数重写成Metal的着色器语言（MSL）。MSL为GPU编程而设计的c++变体。其中，运行在GPU的代码被称为着色器（shader），这是由于这类GPU程序曾首先被应用于计算3D图像中的颜色。示例2展示了与示例1进行同样运算的MSL shader。在官方给出的示例代码中，这个函数定义在add.metal。使用Xcode构建并创建一个默认的Metal库，它会被嵌入到应用程序中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">kernel&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add_arrays&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">device&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">device&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uint&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">thread_position_in_grid&lt;/span>&lt;span class="p">]])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// the for-loop is replaced with a collection of threads, each of which
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// calls this function.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>示例2与示例1相似，当在MSL版本中，有一些重要的区别。仔细观察示例2.&lt;/p>
&lt;p>首先，这个函数加了一个kernel关键字，使这个函数被声明为：&lt;/p>
&lt;ol>
&lt;li>公共（public）GPU函数，程序在调用这个Metal库时，public是仅可见的函数，同时public函数不能被其他shader程序调用。&lt;/li>
&lt;li>计算函数（也称为计算kernel），它通过线程网格（gird）完成并行计算。&lt;/li>
&lt;/ol>
&lt;p>如需了解其他用于声明public图形函数的关键字，请参阅&lt;a href="https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives">使用渲染管道渲染图元&lt;/a>。&lt;/p>
&lt;p>add_arrays 函数用 device 关键字声明了它的三个参数，这表示这些数组指针位于Device地址空间中。MSL定义了若干不相邻的内存区域，每当在MSL中声明一个指针，必须使用一个关键字来声明它的内存地址。使用device修饰的地址空间，代表GPU可以对其进行持续的读写。&lt;/p>
&lt;p>示例2移除了示例1的for循环，因为是被gird中的多线程调用的，这个示例创建了一个与数组维度一致的一维线程网格，因此数组中每一个数值求和是不同线程完成计算的。&lt;/p>
&lt;p>同时示例2使用了一个新的index索引变量替代之前在for循环中的索引，index通过c++的&lt;a href="https://en.cppreference.com/w/cpp/language/attributes">attribute&lt;/a>被赋值为另一个MSL关键词：&lt;em>thread_position_in_grid&lt;/em>，这个关键字表明 Metal 会为每个线程计算一个唯一的索引，并将索引传递给变量。因为add_arrays使用了一维gird，因此index定义为整数（uint）。尽管for循环被移除，示例1和示例2使用相同的方式完成求和。如果想将类似的代码从c/c++转换为MSL，可以使用相同的方式循环逻辑的替换。&lt;/p>
&lt;h2 id="检索gpu">检索GPU&lt;/h2>
&lt;p>在应用程序中，&lt;strong>MTLDevice&lt;/strong>代表一个GPU的简单抽象（Metal设备对象），可通过它完成与GPU的通信。Metal为每一个GPU创建一个MTLDevice，并可通过调用MTLCreateSystemDefaultDevice()获取默认的设备对象。在 macOS 中，Mac 可以有多个 GPU，Metal 会选择其中一个 GPU 作为默认值并返回该 GPU 的MTLDevice，Metal也提供了用于检索所有GPU的其他API，但此示例仅使用默认值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLDevice&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">device&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MTLCreateSystemDefaultDevice&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="初始化metal对象">初始化Metal对象&lt;/h2>
&lt;p>Metal将其他与GPU相关的工作（如编译shader、内存缓存区、图像纹理）表示为不同对象。要创建这些特定的GPU对象。可以通过调用MTLDevice和派生于MTLDevice对象的方法创建这些特定的GPU对象。由GPU的MTLDevice对象直接或间接创建的所有对象仅可用于对应的GPU，对于使用多个GPU的应用程序，Metal会创建多个GPU对象，并为每个对象创建类似的Metal层次结构。&lt;/p>
&lt;p>示例程序中使用一个自定义的类MetalAdder来管理需要与GPU进行通信的对象，在类的初始化中会创建这些对象，并存储在其属性中。在程序中会创建一个该类的示例，传入用于创建辅助对象的 Metal 设备对象。这个MetalAdder对象会在生命周期内保持对Metal对象的强引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">MetalAdder&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">adder&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">MetalAdder&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">initWithDevice&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在Metal中，高消耗的初始化任务可以一次运行之后，将结果保留并在低消耗情况下被使用。很少情况下需要在性能要求严格的代码中执行此类任务。&lt;/p>
&lt;h2 id="调用metal函数">调用Metal函数&lt;/h2>
&lt;p>初始化首先加载这些函数，同时准备在GPU上运行他们。当在build示例程序时，XCode会编译add_arrays函数到一个默认的Metal库，后续应用层会完成对其的调用。使用&lt;strong>MTLLibray&lt;/strong>和&lt;strong>MTLFunction&lt;/strong>的对象去获取Metal库和库中所包含的函数。为获取代表add_array的对象首先需要让MTLDevice为默认库创建一个MTLLibrary对象，然后向库请求一个表示shader函数的MTLFunction对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="o">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">instancetype&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">initWithDevice&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLDevice&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="n">device&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kc">self&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="kc">super&lt;/span> &lt;span class="kd">init&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kc">self&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_mDevice&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">device&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">NSError&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">error&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Load the shader files with a .metal file extension in the project&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLLibrary&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">defaultLibrary&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newDefaultLibrary&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">defaultLibrary&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">NSLog&lt;/span>&lt;span class="p">(@&lt;/span>&lt;span class="s">&amp;#34;Failed to find the default library.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLFunction&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">addFunction&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">defaultLibrary&lt;/span> &lt;span class="n">newFunctionWithName&lt;/span>&lt;span class="p">:@&lt;/span>&lt;span class="s">&amp;#34;add_arrays&amp;#34;&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">addFunction&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">NSLog&lt;/span>&lt;span class="p">(@&lt;/span>&lt;span class="s">&amp;#34;Failed to find the adder function.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="准备metal渲染管线">准备Metal渲染管线&lt;/h2>
&lt;p>上面的函数对象addFunction代表已完成的MSL函数，但它并不是能够直接运行的，需要通过创建一个管线（&lt;em>pipline&lt;/em>），使其能够被执行。pipline会让GPU明确完成一个特定任务所需要执行的步骤。在Metal，pipline会被一个管线状态对象所表示，因为在例程中，两数求和是一个计算函数，因此使用&lt;strong>MTLComputePiplineState&lt;/strong>完成管线对象的创建。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">_mAddFunctionPSO&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newComputePipelineStateWithFunction&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">addFunction&lt;/span> &lt;span class="n">error&lt;/span>&lt;span class="p">:&amp;amp;&lt;/span>&lt;span class="n">error&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>计算pipline会运行单个计算函数，可选地在运行函数之前处理输入数据，运行之后处理输出数据。&lt;/p>
&lt;p>当创建管线状态对象时，设备对象会为特定的GPU编译好需要执行的函数。在示例中，会同步创建管道状态对象，并将其直接返回给应用程序。 因为编译确实需要一段时间，所以避免在性能敏感代码中同步创建管道状态对象。&lt;/p>
&lt;p>&lt;em>原文注：到目前为止，在代码中看到的所有 Metal 返回的对象都是作为符合协议的对象返回的。 Metal 使用协议定义了大多数GPU的特有对象，以完成底层实现类的抽象，这些实现类可能因不同的 GPU 而异。 Metal 使用这些类定义与GPU所独有的对象。 对于是否可以在应用程序中实现该协议可以参阅Metal的参考文档。&lt;/em>&lt;/p>
&lt;h2 id="创建一个指令队列command-queue">创建一个指令队列（Command Queue）&lt;/h2>
&lt;p>向GPU发送工作任务，需要使用指令队列（command queue）实现，同时Metal会使用指令队列，完成对指令的调度。通过MTLDevice完成指令队列的创建。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">_mCommandQueue&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newCommandQueue&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建数据缓存区并加载数据">创建数据缓存区并加载数据&lt;/h2>
&lt;p>在创建好基本的Metal对象之后，需要加在数据以供GPU执行，此任务对性能的要求不高，但最好也在应用程序启动时执行，避免性能损耗。&lt;/p>
&lt;p>GPU可以拥有自己的专用内存，也可以与操作系统共享内存。Metal和操作系统内核需要执行额外的工作才能将数据存储在内存中，并使这些数据可供GPU使用。Metal使用资源类（MTLResource）完成内存资源的管理。resource是GPU在运行命令时可以访问的内存区域。可使用MTLDevice完成对其GPU的resource的创建。&lt;/p>
&lt;p>在示例程序中，创建了三个MTLBuffer，其中前两个使用随机数填充，第三个用来存放add_array的结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">_mBufferA&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newBufferWithLength&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">bufferSize&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">MTLResourceStorageModeShared&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">_mBufferB&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newBufferWithLength&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">bufferSize&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">MTLResourceStorageModeShared&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">_mBufferResult&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newBufferWithLength&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">bufferSize&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">MTLResourceStorageModeShared&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="kc">self&lt;/span> &lt;span class="n">generateRandomFloatData&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mBufferA&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="kc">self&lt;/span> &lt;span class="n">generateRandomFloatData&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mBufferB&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在本示例中，resource为这些MTLBuffer对象，它们是没有预定义格式的内存分配。Metal 将每个缓冲区作为不透明的字节集合进行管理。 但是在shader中使用缓冲区时会指定数据格式。 这意味着shader和应用程序需要就来回传递的任何数据的格式进行统一。&lt;/p>
&lt;p>当分配一个buffer时，需要提供一种存储形式来确定它的一些性能特征，同时需明确CPU/GPU是否可以访问它。在示例程序中，使用共享内存（&lt;a href="https://developer.apple.com/documentation/metal/mtlresourceoptions/1515613-storagemodeshared">storgeModeShared&lt;/a>）来保证CPU和GPU能够访问。&lt;/p>
&lt;p>为向buffer内填随机数，应用程序获取了buffer的指针，并使用cpu向其中写数据。示例2中的arr_arrays函数声明了它的参数为float型的数组指针，所以需要保证buffer内的数据与其类型一致。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="o">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">generateRandomFloatData&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLBuffer&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="n">buffer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">dataPtr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contents&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">unsigned&lt;/span> &lt;span class="n">long&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arrayLength&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dataPtr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">float&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">rand&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">float&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">RAND_MAX&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建一个指令缓存区command-buffer">创建一个指令缓存区（Command Buffer）&lt;/h2>
&lt;p>使用指令队列（_mCommandQueue）对象创建一个指令缓存区。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLCommandBuffer&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">commandBuffer&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mCommandQueue&lt;/span> &lt;span class="n">commandBuffer&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建一个指令编码器command-encoder">创建一个指令编码器（Command Encoder）&lt;/h2>
&lt;p>为了向指令缓存中写指令，需要使用Command Encoder来处理编码时的特定指令。此示例创建一个计算命令编码器，该编码器对计算通道进行编码。 计算通道包含执行计算管道的命令列表。 每个计算命令都会使 GPU 创建一个线程网格以在 GPU 上执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLComputeCommandEncoder&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">computeEncoder&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">commandBuffer&lt;/span> &lt;span class="n">computeCommandEncoder&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要对指令进行编码，需要对编码器进行一系列方法的调用，其中主要为设置状态信息，如管道状态对象 (pipeline state object,PSO) 或要传递给管道的参数。 进行这些状态更改后，命令进行编码以执行pipline。编码器会将所有状态变化和命令参数写入命令缓冲区。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0904/command_encoder.png" alt="Command Encoder">&lt;/p>
&lt;h2 id="设置管线状态和参数信息">设置管线状态和参数信息&lt;/h2>
&lt;p>首先需要设置对应pipline的状态，即PSO，然后针对需要发送到add_arrays函数的每一个参数进行配置。对于此pipline，需要对三个buffer进行配置。 Metal 按照参数出现在示例2中的顺序自动为buffer参数分配索引，从 0 开始。您使用相同的索引提供参数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">setComputePipelineState&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mAddFunctionPSO&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">setBuffer&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mBufferA&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="n">atIndex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">setBuffer&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mBufferB&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="n">atIndex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">setBuffer&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mBufferResult&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="n">atIndex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时也需要制定参数的偏移量（offset），当偏移量为0时，表明command会从buffer的起始位置获取参数。但也可以使用一个buffer存储多个参数，为每一个参数指定一个独立的offset。&lt;/p>
&lt;p>可以看出，程序中没有为add_arrays的index参数指定任何数据，这是由于该值由GPU提供。&lt;/p>
&lt;h2 id="指定线程数并组织线程">指定线程数并组织线程&lt;/h2>
&lt;p>下一步，确定需要创建多少线程，并如何组织这些线程。Metal能够创建一维、二维、三维的线程网格。由于add_arrays使用的是一维数组，所以例程中创建了一个长度为数组长度的一维网格&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">MTLSize&lt;/span> &lt;span class="n">gridSize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MTLSizeMake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arrayLength&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="指定线程组threadgroup大小">指定线程组（Threadgroup）大小&lt;/h2>
&lt;p>Metal为网格细分为更小的结构，叫做线程组（Threadgroup）。每个线程组都是单独计算的。 Metal 可以将线程组分派给 GPU 上的不同处理元素以加快处理速度。 同样也需要决定为指令创建对应尺寸的线程组。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">NSUInteger&lt;/span> &lt;span class="n">threadGroupSize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_mAddFunctionPSO&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">maxTotalThreadsPerThreadgroup&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">threadGroupSize&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arrayLength&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threadGroupSize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayLength&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">MTLSize&lt;/span> &lt;span class="n">threadgroupSize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MTLSizeMake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">threadGroupSize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在例程中，使用PSO获取了最大的线程组尺寸，如果这个长度大于参数的本身长度，则需要调整threadGroupSize为对应的大小。&lt;/p>
&lt;p>maxTotalThreadsPerThreadgroup 属性给出线程组中允许的最大线程数，这取决于用于创建管道状态对象的函数复杂性。&lt;/p>
&lt;h2 id="编码计算指令并在线程中执行">编码计算指令并在线程中执行&lt;/h2>
&lt;p>最后，对指令进行编码去分配线程网格。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">dispatchThreads&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">gridSize&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threadsPerThreadgroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">threadgroupSize&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当GPU运行这个指令，会使用先前设置好的状态和命令的参数来调度线程来执行计算。
可以使用编码器按照相同的步骤将多个计算命令编码到计算通道中，而无需执行任何冗余步骤。 例如，可以设置管道状态对象一次后，设置参数为要处理的每个缓冲区集合编码一个命令。&lt;/p>
&lt;h2 id="结束计算通道">结束计算通道&lt;/h2>
&lt;p>当没有更多的指令进入计算通道时，需要结束编码关闭计算通道。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">endEncoding&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="提交命令缓冲区以执行其命令">提交命令缓冲区以执行其命令&lt;/h2>
&lt;p>指令缓冲（command buffer）提交命令到指令队列（command queue），然后queue来运行命令缓冲区中的命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">commandBuffer&lt;/span> &lt;span class="n">commit&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>指令队列创建了指令缓存，因此提交缓存总是将其放入队列中。在提交指令缓存后，Metal会进行预处理操作，然后安排command buffer在GPU上执行。GPU在执行完缓存中的command之后，Metal会将缓存区标记成已完成。&lt;/p>
&lt;h2 id="等待计算完成">等待计算完成&lt;/h2>
&lt;p>在GPU处理command的时候，应用程序可以完成其他的工作，在示例程序中，应用层不需要处理额外的工作，所以只需要简单地等待command buffer完成任务。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">commandBuffer&lt;/span> &lt;span class="n">waitUntilCompleted&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样的，也可在Metal完成command的时候，向command buffer添加一个完成的句柄（handler），也可以读取command buffer的状态属性，获取command是否完成。&lt;/p>
&lt;h2 id="从缓存中读取结果">从缓存中读取结果&lt;/h2>
&lt;p>在command buffer完成之后，GPU的计算结果存储在输出缓存中，Metal需要执行一些必要的步骤使其能够被CPU所读取。在一个真正的应用程序中，你可以在输出中读到结果，并在之后可对其进行相关操作，例如在屏幕上显示，或把它们写入文件。由于例程仅用于说明创建 Metal 应用程序的过程，因此只会读取存储在输出缓冲区中的值并进行测试以确保 CPU 和 GPU 计算出相同的结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="o">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">verifyResults&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_mBufferA&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contents&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_mBufferB&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contents&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_mBufferResult&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contents&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">unsigned&lt;/span> &lt;span class="n">long&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arrayLength&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Compute ERROR: index=%lu result=%g vs %g=a+b&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">index&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Compute results as expected&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>MVC MVP MVVM架构浅析</title><link>https://ingslh.com/post/2022-06-18-mvc-mvp-mvvm%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</link><pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-06-18-mvc-mvp-mvvm%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</guid><description>&lt;p>&lt;strong>MVC&lt;/strong>、&lt;strong>MVP&lt;/strong>和&lt;strong>MVVM&lt;/strong>是三种用以实现软件系统中用户界面与逻辑层解耦的抽象架构模型，其中后两种算是&lt;strong>MVC&lt;/strong>的变形。作为三种最常用的三种架构设计模式，它们有着各自不同的的应用场景，结合自己之前的经验，来简单总结下它们的特点。&lt;/p>
&lt;p>&lt;em>在实际开发中，选用的架构可以看作是一种骨架，结合业务需求往往需要在骨架的基础上进行一些改造并丰富细节。&lt;/em>&lt;/p>
&lt;h2 id="mvc">MVC&lt;/h2>
&lt;p>MVC（Model-View-Controller）模式主要分为三个部分，分别是模型、视图和控制器。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mvc.png" alt="MVC结构图">&lt;/p>
&lt;ul>
&lt;li>模型（Model）：处理底层业务逻辑，实现相关运算；&lt;/li>
&lt;li>视图（View）：页面显示，完成与用户的交互；&lt;/li>
&lt;li>控制器（Controller）：完成模型与视图的数据（或命令）通信，完成应用层面的相关任务；&lt;/li>
&lt;/ul>
&lt;p>从上图的通信流程图来看，三个模块间的通信是单向的，首先用户操作视图，传达相应的指令到控制器，控制器将指令解析，传递给模型进行相应的处理，如果需要将结果反馈给视图，则再将指令传递给视图，最终视图完成更新。&lt;/p>
&lt;h2 id="mvp">MVP&lt;/h2>
&lt;p>MVP(Model-View-Presenter)是从经典的MVC演变过来的，但是由于model和view之间不进行直接连接，而是将presenter作为桥梁，完成从view到model到数据传输，以及从model到view到界面更新。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mvp.png" alt="MVP结构图">&lt;/p>
&lt;p>它的特点总结是：&lt;/p>
&lt;ul>
&lt;li>各部分之间的通信，是双向的；&lt;/li>
&lt;li>Presenter就是相对于MVC中的Controller，为了便于区分，将控制器命名为Presenter；&lt;/li>
&lt;li>Presenter可以对应多个view，控制接口后，能应对来自于view的复杂变化；&lt;/li>
&lt;/ul>
&lt;p>从结构上来看，mvp中因为view与model不直接通信，降低了整个系统的耦合程度，相比较mvc来说，view由于只被动地处理界面，因此被称为“被动视图”（Passive View），随之而来造成presenter的变重，除了要完成整个业务逻辑的实现，还要加上对view的控制。&lt;/p>
&lt;h2 id="mvvm">MVVM&lt;/h2>
&lt;p>MVVM（Model-View-ViewModel），最大的区别是将控制器（controller/presenter）换成了ViewModel（VM），与之对应的VM在功能方面，也进行了更新。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mvvm.png" alt="MVVM结构图">&lt;/p>
&lt;p>从结构图来看，与MVP的变化不大，但对于VM来说，它与model采用双向绑定（data-binding）的形式，即如果View和ViewModel任意一方发生变化时，另一方会自动更新。&lt;/p>
&lt;h2 id="在多视图下的应用">在多视图下的应用&lt;/h2>
&lt;p>考虑一种“&lt;strong>复杂软件&lt;/strong>”的情况，即主视图（parent-view）下存在着多个子视图（child-view），每个视图之间的业务逻辑各不相同，但从界面的角度来说又各自关联，如何套用到上述的三种模型中呢？&lt;/p>
&lt;p>以&lt;strong>MVP&lt;/strong>模型举例，当然可以把多个视图抽象成一个整体，这样看就与前面的流程图差不多，但从模型和presenter的角度来说，它们会变得很臃肿且耦合度高（在presenter/model下，将所有view对应的指令和实现放在一起）。&lt;/p>
&lt;p>在尽可能低耦合的目标下，可以针对每一个view，构建对应的model和presenter，其中presenter不单要完成模块内（与自身model和view）的指令传递，也要完成与其他模块（其他presenter）的通信，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mulit-view.png" alt="多视图下的应用">&lt;/p>
&lt;p>如果这个&lt;strong>复杂软件&lt;/strong>需要多个开发人员协作时，只要把presenter间的接口确定好，每个开发人员可以最大程度上专注于自己所负责模块的功能实现。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>最后以一句老生常谈的话作为总结：&lt;/p>
&lt;blockquote>
&lt;p>适用于任何情况的架构设计模型是不存在的，只能在结合实际需求的情况下寻找或创造一种&lt;strong>相对&lt;/strong>适合的模型。&lt;/p>
&lt;/blockquote>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://henleylee.github.io/posts/2019/de9d67a4.html">MVC、MVP 和 MVVM 之间的区别&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">MVC，MVP 和 MVVM 的图示&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/6901200799242649607">正确认识 MVC/MVP/MVVM&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Hugo + Github Pages搭站记录</title><link>https://ingslh.com/post/2022-06-10-hugo+githubpages%E6%90%AD%E7%AB%99%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-06-10-hugo+githubpages%E6%90%AD%E7%AB%99%E8%AE%B0%E5%BD%95/</guid><description>&lt;p>伴随Web技术的蓬勃发展，使得构建静态网站的成本越来越低，这个博客是通过Hugo和GitHub Pages完成的构建，作为博客的第一篇文章，主要介绍下这个博客的搭建过程，虽然现在网上相关的资料已经非常丰富，但是我在建站的过程中还是遇到了很多问题，抱着分享与总结的目的，在这里记录下我的实现流程供大家参考。🌟&lt;/p>
&lt;h3 id="文中所使用的软件版本">文中所使用的软件版本&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Version&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Hugo&lt;/td>
&lt;td>0.98&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Git&lt;/td>
&lt;td>2.36&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>如果需要编译Hugo源码,需要Go1.3+&lt;/em>&lt;/p>
&lt;h3 id="简述">简述&lt;/h3>
&lt;p>在github上建立两个仓库，一个作为&lt;strong>源码仓库&lt;/strong>(&lt;em>user.github.io.src&lt;/em>)，另一个作为用于&lt;strong>主页仓库&lt;/strong>(&lt;em>user.git.io&lt;/em>)。将主页仓库作为源码仓库的子模块，利用Github Actions，使源码repo在push时将编译结果输出到主页repo中，然后页面repo利用GitHub Pages渲染实现一个博客站点。一般将源码repo设为私有库，同时并不影响主页repo里的页面展示。&lt;/p>
&lt;blockquote>
&lt;p>与此同时，还有两种实现方式：一种是使用Hugo创建的site主目录作为Github Pages的运行根，还有一种是使用hugo编译后的publishDir作为Github Pages的运行根。两种方式都能够渲染出页面，但也都有各自的问题：第一种方式会暴露你的相关信息，例如配置文件下的个人信息，未发表的草稿等等都会展示在github上；第二种方式由于没有git仓库建立在你的源码目录上，因此不能进行有效的版本管理，维护起来会很麻烦。&lt;/p>
&lt;/blockquote>
&lt;h2 id="主要流程">主要流程&lt;/h2>
&lt;h3 id="1安装hugo和git">1.安装hugo和git&lt;/h3>
&lt;p>hugo和git都可通过官网上的指南进行安装，&lt;a href="https://gohugo.io/getting-started/installing/">Install Hugo｜Hugo&lt;/a> 和&lt;a href="https://git-scm.com/downloads">Git-Downloads&lt;/a>;&lt;/p>
&lt;p>在终端输入&lt;code>hugo version&lt;/code>和&lt;code>git version&lt;/code>验证是否安装成功。&lt;/p>
&lt;h3 id="2创建github仓库">2.创建Github仓库&lt;/h3>
&lt;p>创建如下图所示的两个&lt;strong>空&lt;/strong>仓库，其中将用户名替换成自己的，源码仓库（&lt;em>user.github.io.src&lt;/em>）命名可以任意，但是为了便于区分，加上了后缀 &lt;strong>.src&lt;/strong>。
&lt;img src="https://ingslh.com/img/github_repo.jpeg" alt="">&lt;/p>
&lt;h3 id="3新建hugo网站">3.新建Hugo网站&lt;/h3>
&lt;p>通过终端将源码库（&lt;em>user.github.io.src&lt;/em>）clone到本地，进入该文件夹，使用&lt;code>hugo new&lt;/code>创建Hugo网站&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git clone https://github.com/user/user.github.io.src.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> user.github.io.src
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">hugo new site . --force
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这里没有现在本地创建git仓库的原因是，新建本地仓库的默认分支为&lt;code>master&lt;/code>，而github上新建仓库的默认分支为&lt;code>main&lt;/code>，连接远程仓库的时候，要再建一个&lt;code>main&lt;/code>分支，并把&lt;code>master&lt;/code>分支删去。&lt;/p>
&lt;/blockquote>
&lt;h3 id="4添加主题">4.添加主题&lt;/h3>
&lt;p>需要为新建的site选择一个合适的主题，可以在&lt;a href="https://themes.gohugo.io">Hugo Themes&lt;/a>挑选一个自己喜欢的，在挑选主题时，建议先看下所用主题的README，下面就以本站使用的&lt;strong>BeautifulHugo&lt;/strong>举例；&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ mkdir themes &lt;span class="c1">#在源码repo的根目录下执行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ &lt;span class="nb">cd&lt;/span> themes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git submodule add https://github.com/halogenica/beautifulhugo.git beautifulhugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样&lt;code>themes&lt;/code>的文件夹下会有&lt;code>beautifulhugo&lt;/code>的主题了，由于是建立的新hugo工程，可以根据&lt;code>exampleSite&lt;/code>下的&lt;code>config.toml&lt;/code>修改自己的主目录下的&lt;code>config.toml&lt;/code>，&lt;strong>建议直接拷贝过去，再修改上自己的一些信息。&lt;/strong>&lt;/p>
&lt;p>一开始也可以把&lt;code>exampleSite&lt;/code>下的&lt;code>content&lt;/code>文件夹复制到主目录进行覆盖。&lt;/p>
&lt;blockquote>
&lt;p>一般&lt;code>exampleSite&lt;/code>会有&lt;code>content&lt;/code>、&lt;code>layouts&lt;/code>、&lt;code>static&lt;/code>文件夹，可以根据自己需要把它们拷贝到主目录下。&lt;/p>
&lt;/blockquote>
&lt;p>然后就可以通过hugo的&lt;code>server&lt;/code>命令，预览主题效果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ hugo server &lt;span class="c1">#如果希望显示草稿（draft）可以加上 —D&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当返回信息包含如下时，可进入&lt;a href="http://localhost:1313/">http://localhost:1313/&lt;/a>进行预览。&lt;/p>
&lt;blockquote>
&lt;p>如果效果异常，大概率是配置文件（config.toml）修改得不正确。请参照所使用主题的README和Hugo的官方文档进行检查。&lt;/p>
&lt;/blockquote>
&lt;h3 id="5配置token">5.配置token&lt;/h3>
&lt;p>下面需要为Github Actions的自动部署配置token，配置方法如下：&lt;/p>
&lt;p>首先通过github生成token，在你的github主页下点击头像框，依次进入&lt;strong>Setting-&amp;gt;Developer Settings-&amp;gt;Personal access tokens&lt;/strong>&lt;/p>
&lt;p>选择Generate new token，按规则填入note和expiration，其中expiration可以尽量填大一些，避免后续需要频繁更新。&lt;/p>
&lt;p>勾选下面的&lt;code>repo&lt;/code>和&lt;code>admin:repo_hook&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/token_config.png" alt="配置token">&lt;/p>
&lt;p>点击&lt;code>Generate token&lt;/code>进行生成，并复制token。&lt;/p>
&lt;p>生成后需要在源码repo中添加新生成的token，在github的源码repo中通过Settings-&amp;gt;Secrets-&amp;gt;Actions进入，填写Name和Value，其中Name可以自己定义（我定义的是ACTION_ACCESS_TOKEN，后续配置workflow会用到），Value中填入之前复制的token。&lt;/p>
&lt;blockquote>
&lt;p>实现Actions的自动部署还有一种方式是关联源码repo和页面repo的ssh key，过程会相对繁琐些，且在实际配置后，push源码repo时，Actions会报错&lt;code>Action failed with &amp;quot;The process '/usr/bin/ssh-add' failed with exit code 1&amp;quot;&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h3 id="6设置workflow">6.设置workflow&lt;/h3>
&lt;p>生成token后，在源码仓库的Actions中新建一个workflow，根据&lt;a href="https://github.com/peaceiris/actions-hugo#getting-started">Github Actions for Hugo&lt;/a>进行填写，我的workflow.yml如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy Hugo Site to Github Pages on Main Branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">push&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">branches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build-deploy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-18.04&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v1 &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># v2 does not have submodules option now&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">submodules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">fetch-depth&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch all history for .GitInfo and .Lastmod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Setup Hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-hugo@v2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#hugo官方提供的action，用于在任务环境中获取hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">hugo-version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;latest&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># extended: true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Build&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hugo --minify&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#构建静态网页，默认存在publish文件夹下&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-gh-pages@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">personal_token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.ACTION_ACCESS_TOKEN }}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># ACTION_ACCESS_TOKEN修改成之前填写secret的名字&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">external_repository&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">username/ingslh.github.io&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Pages远程仓库,更换username &lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_dir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#默认发布public文件夹里的内容&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">keep_files&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># remove existing files&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_branch&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># deploying branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">commit_message&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ github.event.head_commit.message }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>commit后该yml会生成在repo的./github/worksflows下。&lt;/p>
&lt;h3 id="7自动部署发布">7.自动部署发布&lt;/h3>
&lt;p>在本地的源码仓库的根目录下中提交修改到远程库，actions会自动帮你把hugo编译的静态页面推送到页面repo中，完成部署。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git add .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s2">&amp;#34;commit info&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git pull --rebase &lt;span class="c1">#由于远程库更新了workflow文件，所以需要pull下&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回到github的源码repo中，点击Actions，查看自动部署是否成功，如果成功部署会出现如下结果：
&lt;img src="https://ingslh.com/img/actions_success.png" alt="部署成功">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>至此已完成了通过Hugo+Github pages对个人博客的搭建，其实对于初始博客还有很多地方可以优化，比如加入评论系统，加入暗色模式，对多语言的支持等等，之后的更新也同样会进行记录。😄&lt;/p></description></item><item><title>About me</title><link>https://ingslh.com/page/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/page/about/</guid><description>&lt;p>😄Hi！欢迎来到我的博客，我是ingslh，一名c/c++程序员，平时主要做一些音视频开发、图形图像渲染的工作，目前坐标长沙。&lt;/p>
&lt;p>一些爱好：&lt;/p>
&lt;ul>
&lt;li>🎵：后朋(&lt;em>PostPunk&lt;/em>)、放克(&lt;em>Funk&lt;/em>);&lt;/li>
&lt;li>🎮：杀戮尖塔（&lt;em>Slay the Spire&lt;/em>）、极乐迪斯科(&lt;em>Disco Elysium&lt;/em>);&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;em>不太好写，随便写一些近期的&lt;/em>🤔&lt;/p>
&lt;/blockquote>
&lt;p>关于职场身份，理想是成为一名独立开发者，希望有生之年能实现吧。&lt;/p>
&lt;p>建立这个博客的目的是记录我在工作和平时折腾的过程中遇到的一些问题与解决这些问题的收获。&lt;/p>
&lt;p>最后想分享下吴军博士提出的工程师的“五个等级”：&lt;/p>
&lt;ul>
&lt;li>5.能独立解决问题，完成工程工作；&lt;/li>
&lt;li>4.指导和带领其他人一起完成更有影响力的工作；&lt;/li>
&lt;li>3.独立设计和实现产品，并在市场上成功；&lt;/li>
&lt;li>2.设计和实现别人不能做的产品；&lt;/li>
&lt;li>1.开创一个产业；&lt;/li>
&lt;/ul>
&lt;p>&lt;em>自评下，我应该5还没有达到&lt;/em> :(&lt;/p></description></item></channel></rss>