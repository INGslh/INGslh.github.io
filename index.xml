<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ingslh's Blog</title><link>https://ingslh.com/</link><description>Recent content on Ingslh's Blog</description><generator>Hugo -- gohugo.io</generator><managingEditor>ingslh@foxmail.com (ingslh)</managingEditor><webMaster>ingslh@foxmail.com (ingslh)</webMaster><lastBuildDate>Sun, 18 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ingslh.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Apple Metal文档（3）：使用渲染管线渲染图形</title><link>https://ingslh.com/post/2022-09-18-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-3/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-09-18-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-3/</guid><description>&lt;blockquote>
&lt;p>本文翻译自苹果Metal的官方文档：&lt;a href="https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives">Using a Render Pipeline to Render Primitives&lt;/a>，目的主要是为了加深自己的理解，如果哪里翻译有误，请大家指出，我会及时更正。欢迎转载，但禁止用于商业用途。谢谢！&lt;/p>
&lt;/blockquote>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>这个例程向你展示了如何配置一个渲染管线，并作为渲染通道一部分去绘制一个简单的2D三角形到视图中。该示例为每个顶点提供了位置和颜色信息，渲染管道使用该数据渲染三角形，并为三角形顶点指定的颜色之间插入颜色值。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0918/vertex_img.png" alt="顶点数据">&lt;/p>
&lt;p>Xcode 项目包含用于在 macOS、iOS 和 tvOS 上运行示例的方案。&lt;/p>
&lt;h2 id="理解metal渲染管线">理解Metal渲染管线&lt;/h2>
&lt;p>渲染管线（pipline）用于处理绘图指令，并将图元数据写到渲染通道的目标中去。一个渲染管线会有很多阶段，其中一些需要使用着色器进行编程，另一些具有固定或可配置的属性。这个例程聚焦于渲染管线的三个主要阶段：顶点阶段、光栅化阶段和片段阶段，其中顶点阶段和片段阶段是可编程的，因此需要使用Metal着色器语言（MSL），而在光栅化阶段是被固定的。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0918/pipline.png" alt="pipline">&lt;/p>
&lt;p>渲染首先通过一个绘图命令开始，包含顶点数量，需要绘制什么样的图形。下面是例程中的绘图指令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Draw the triangle.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">renderEncoder&lt;/span> &lt;span class="n">drawPrimitives&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">MTLPrimitiveTypeTriangle&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vertexStart&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vertexCount&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在顶点阶段会为每个顶点提供坐标信息，当顶点被处理完成，渲染管线会对图形进行光栅化处理，以确定渲染目标中的哪些像素位于图形的边界内。在片段阶段会确定这些像素的颜色值，并把它们写到渲染目标中。&lt;/p>
&lt;p>在本示例的其余部分，将看到如何编写顶点和片段函数，如何创建渲染管道状态对象，最后，如何编码使用此管道的绘图命令。&lt;/p>
&lt;h2 id="自定义渲染管线如何处理数据">自定义渲染管线如何处理数据&lt;/h2>
&lt;p>顶点函数会对每个顶点生成数据，片段函数会为图形上的片段生成数据，我们可以自定义其工作过程。配置管道的各个阶段时要记住一个目标，这意味着您知道希望管道生成什么以及它如何生成这些结果。&lt;/p>
&lt;p>决定将什么数据传入你的渲染管线以及什么样的数据会在后续阶段通过渲染管线。总体上有三点需要你做的：&lt;/p>
&lt;ol>
&lt;li>管道的输入，由您的应用程序提供并传递到顶点阶段。&lt;/li>
&lt;li>顶点阶段的输出，传递到光栅化阶段。&lt;/li>
&lt;li>片段阶段的输入，由您的应用程序提供或由光栅化阶段生成。&lt;/li>
&lt;/ol>
&lt;p>在本示例中，渲染管线的输入是顶点的位置坐标和颜色数据。输入坐标在自定义坐标空间中定义，以距视图中心的像素为单位。这些坐标需要转换为 Metal 的坐标系。&lt;/p>
&lt;p>声明一个AAPLVertex结构体，使用 SIMD 矢量类型来保存位置和颜色数据。要共享一个关于结构在内存中的布局方式的定义，请在公共标头中声明结构并将其导入 Metal 着色器和应用程序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">typedef&lt;/span> &lt;span class="kd">struct&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vector_float2&lt;/span> &lt;span class="n">position&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vector_float4&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">AAPLVertex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SIMD 类型在 Metal Shading Language 中很常见，您还应该使用 simd 库在您的应用程序中使用它们。SIMD 类型包含特定数据类型的多个通道，所以以vector_float（包含2个32位的float）格式声明坐标，颜色信息使用vector_float4进行存储，包含红、绿、蓝、透明度通道。&lt;/p>
&lt;p>在应用程序中，输入数据使用常量数组指定：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">static&lt;/span> &lt;span class="n">const&lt;/span> &lt;span class="n">AAPLVertex&lt;/span> &lt;span class="n">triangleVertices&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="p">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 2D positions, RGBA colors&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mi">250&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">250&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">250&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">250&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">250&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>顶点阶段为顶点生成数据，因此它需要提供颜色和变换后的位置。 然后使用 SIMD 类型声明包含位置和颜色值的 RasterizerData 结构体。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">struct&lt;/span> &lt;span class="nc">RasterizerData&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// The [[position]] attribute of this member indicates that this value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// is the clip space position of the vertex when this structure is&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// returned from the vertex function.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">float4&lt;/span> &lt;span class="n">position&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">position&lt;/span>&lt;span class="p">]];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Since this member does not have a special attribute, the rasterizer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// interpolates its value with the values of the other triangle vertices&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// and then passes the interpolated value to the fragment shader for each&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// fragment in the triangle.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">float4&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出的位置信息（下面详细描述）必须定义为vector_float4。 颜色在输入数据结构中被声明。&lt;/p>
&lt;p>需要告诉 Metal 光栅化数据中的哪个字段提供位置数据，因为 Metal 不会对结构中的字段强制执行任何特定的命名约定。 使用 [[position]] 属性限定符注释位置字段以声明此字段包含输出位置。&lt;/p>
&lt;p>片段函数只是将光栅化阶段的数据传递到后面的阶段，因此它不需要任何额外的参数。&lt;/p>
&lt;h2 id="声明顶点函数">声明顶点函数&lt;/h2>
&lt;p>声明顶点函数，包括它的输入参数和它输出的数据。 就像使用 kernel 关键字声明计算函数一样，您使用 vertex 关键字声明顶点函数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">vertex&lt;/span> &lt;span class="n">RasterizerData&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">vertexShader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uint&lt;/span> &lt;span class="n">vertexID&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">]],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">constant&lt;/span> &lt;span class="n">AAPLVertex&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">vertices&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AAPLVertexInputIndexVertices&lt;/span>&lt;span class="p">)]],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">constant&lt;/span> &lt;span class="n">vector_uint2&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">viewportSizePointer&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AAPLVertexInputIndexViewportSize&lt;/span>&lt;span class="p">)]])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一个参数 vertexID 使用 [[vertex_id]] 属性限定符，这是另一个 Metal 关键字。 当您执行渲染命令时，GPU 会多次调用您的顶点函数，为每个顶点生成一个唯一值。&lt;/p>
&lt;p>第二个参数 vertices 是一个包含顶点数据的数组，使用之前定义的 AAPLVertex 结构。&lt;/p>
&lt;p>要将位置转换为 Metal 的坐标，该函数需要绘制三角形的视口大小（以像素为单位），因此它存储在 viewportSizePointer 参数中。&lt;/p>
&lt;p>第二个和第三个参数具有 [[buffer(n)]] 限定符。 默认情况下，Metal 会自动为每个参数分配参数表中的接收对象。 当您将 [[buffer(n)]] 限定符添加到缓冲区参数时，您会明确告诉 Metal 使用哪个接收对象。 显式声明可以更轻松地修改着色器，而无需更改应用程序代码。 在共享头文件中声明两个索引的常量。&lt;/p>
&lt;p>这个函数会输出一个RasterizerData对象。&lt;/p>
&lt;h2 id="编写顶点数据">编写顶点数据&lt;/h2>
&lt;p>顶点函数必须包含输出结构体的两个字段，使用 vertexID 参数来索引顶点数组并读取顶点的输入数据。 此外，需要获取绘制图像视图的尺寸。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">float2&lt;/span> &lt;span class="n">pixelSpacePosition&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">vertices&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vertexID&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">xy&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Get the viewport size and cast to float.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">vector_float2&lt;/span> &lt;span class="n">viewportSize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">vector_float2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">viewportSizePointer&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>顶点函数必须提供空间坐标中的位置数据，这些坐标是使用四维齐次向量 (x,y,z,w) 指定的 3D 点。光栅化阶段获取输出位置并将 x、y 和 z 坐标除以 w，以在归一化设备坐标中生成 3D 点。 归一化设备坐标与视口大小无关。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0918/positions.png" alt="空间坐标">&lt;/p>
&lt;p>归一化坐标使用左手坐标系（opengl为右手）并映射到视图上的坐标系；在此坐标系中裁切出一个框，包裹住需要绘制的图形，进而进行光栅化；裁切框的左下角位于x-y坐标系上，坐标为（-1.0，-1.0），右上角位于（1.0,1.0）。z轴的正值指向远离摄像机的方向（远离屏幕），z轴的可见范围为0.0～1.0之间。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0918/transform_coordinates.png" alt="变换坐标">&lt;/p>
&lt;p>因为这是一个 2D 的应用程序，因此不需要齐次坐标，首先会将默认值写入输出坐标，其中 w 值设置为 1.0，其他坐标设置为 0.0。这意味着顶点坐标已经归一化在空间坐标中，同时顶点函数会在这个坐标空间之中，生成对应的（x，y）坐标。将输入位置除以视口大小的一半以生成标准化设备坐标。 由于此计算是使用 SIMD 类型执行的，因此可以使用一行代码同时划分两个通道。 执行除法并将结果放在输出位置的 x 和 y 通道中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">position&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">vector_float4&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">xy&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">pixelSpacePosition&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">viewportSize&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mf">2.0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后将颜色信息赋值给输出的color字段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">color&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">vertices&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vertexID&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="编写片段函数">编写片段函数&lt;/h2>
&lt;p>渲染目标的片段（fargment）是可通过着色器配置的，光栅化会确定渲染目标的哪些像素被图元覆盖。 只有像素中心在三角形内的片段才会被渲染。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0918/fragment.png" alt="片段渲染">&lt;/p>
&lt;p>片段函数处理来自光栅器的单个位置的传入信息，并计算每个渲染目标的输出值。 这些片段值由渲染管线中的后续阶段处理，并最终被写入渲染目标。&lt;/p>
&lt;p>片段可更改的原因是因为片段阶段之后的渲染管线可以配置为拒绝某些片段或更改写入渲染目标的内容。 在此示例中，片段阶段计算的所有值都按原样写入渲染目标。&lt;/p>
&lt;p>此示例中的片段着色器接收参数与顶点着色器输出参数相同。使用 fragment 关键字声明片段函数。它只有一个参数，即顶点阶段提供的RasterizerData 结构体。添加 [[stage_in]] 属性限定符以指示此参数由光栅器生成。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">fragment&lt;/span> &lt;span class="n">float4&lt;/span> &lt;span class="n">fragmentShader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RasterizerData&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">stage_in&lt;/span>&lt;span class="p">]])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果您的片段函数对应多个渲染目标，它必须为每个渲染目标声明一个结构体。 因为这个示例只有一个渲染目标，所以您直接指定一个浮点向量作为函数的输出。 此输出是要写入渲染目标的颜色。&lt;/p>
&lt;p>光栅化阶段计算每个片段参数的值并使用它们调用片段函数。 光栅化阶段将其颜色参数计算为三角形顶点处颜色的混合。 片段离顶点越近，顶点颜色对最终颜色的影响就越大。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0918/fragment_color.png" alt="片段着色">&lt;/p>
&lt;p>片段函数会返回插值颜色作为函数的输出。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="k">return&lt;/span> &lt;span class="k">in&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建渲染管线状态对象">创建渲染管线状态对象&lt;/h2></description></item><item><title>Apple Metal文档（2）：使用Metal绘制视图内容</title><link>https://ingslh.com/post/2022-09-08-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-2/</link><pubDate>Thu, 08 Sep 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-09-08-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-2/</guid><description>&lt;blockquote>
&lt;p>本文翻译自苹果Metal的官方文档：&lt;a href="https://developer.apple.com/documentation/metal/using_metal_to_draw_a_view_s_contents">Using Metal to Draw a View’s Contents&lt;/a>，目的主要是为了加深自己的理解，如果哪里翻译有误，请大家指出，我会及时更正。欢迎转载，但禁止用于商业用途。谢谢！&lt;/p>
&lt;/blockquote>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>在本示例中，将学习使用 Metal 渲染图形内容的基础知识。 将使用 MetalKit 框架创建一个用于Metal绘制图形的视图。 然后，将编写代码完成擦除视图内容为一个固定的背景颜色的操作。&lt;/p>
&lt;p>&lt;em>注：MetalKit能够自动执行窗口系统任务、加载纹理并处理3D模型数据。&lt;a href="https://developer.apple.com/documentation/metalkit">MetalKit&lt;/a>&lt;/em>&lt;/p>
&lt;h2 id="准备绘制一个metalkit视图">准备绘制一个MetalKit视图&lt;/h2>
&lt;p>MetalKit提供了一个叫做MTKView的类，它是NSView（macos）和UIView（ios和tvOs）。在使用Matel渲染图形时，MetalKit会处理其实现细节。&lt;/p>
&lt;p>为创建内部资源，MetalKit需要获取一个Metal设备对象的引用，因此第一步是为视图的device属性设置一个存在的MTLDevice对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">_view&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">device&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MTLCreateSystemDefaultDevice&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MetalKit上的其他一些属性同样也需要进行初始化。为了能够实现对渲染内容进行清除、显示背景颜色的操作，需要对clearColor属性进行配置，可以使用MTLClearColorMake函数完成对其的初始化。MTLClearColorMake共有四个参数，分别对应红、绿、蓝、透明度通道。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">_view&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clearColor&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MTLClearColorMake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为这个示例不需要绘制动画，设置视图仅在需要更新内容的时候刷新，例如当视图的形状发生改变时。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">_view&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">enableSetNeedsDisplay&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">YES&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="委托绘制工作">委托绘制工作&lt;/h2>
&lt;p>MetalKit需要依赖Metal向应用程序发送绘制指令，MetalKit需要通过delegate属性设置应用程序何时进行渲染。若要通过delagate实现回调，需要将视图的delegate属性设置为符合 MTKViewDelegate 协议的对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">_view&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">delegate&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_renderer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个delegate内实现两个函数：&lt;/p>
&lt;ol>
&lt;li>无论何时，当视图的尺寸发生变化时，会自动调用mtkView(_:drawableSizeWillChange:) 。除了尺寸属性变化，这一过程还包括渲染的目标系统发生改变时。&lt;/li>
&lt;li>当视图的内容需要更新时，会调用draw（in：）函数。其主要流程是，创建一个命令缓冲区（command buffer），包含通知 GPU 绘制什么并何时在屏幕上显示的命令，并将该命令缓冲区排入队列以由 GPU 执行。 这有时被称为绘制框架。 每绘制一帧是生成单个图像并显示在屏幕上。 在像游戏这样的交互式应用程序中，您每秒可能会绘制许多帧。&lt;/li>
&lt;/ol>
&lt;p>在示例中，使用一个叫做AAPLRender的类实现委托，并承担绘制的工作。在MetalView中创建了一个这个类的接口，通过view的delegate进行配置。&lt;/p>
&lt;h2 id="创建渲染通道描述符">创建渲染通道描述符&lt;/h2>
&lt;p>当您绘制时，GPU 将结果存储到&lt;em>Texture&lt;/em>中，Texture是包含图像数据并且可供 GPU 访问的内存块。 在这个示例中，MTKView 创建了您需要绘制到视图中的所有Texture。 它创建多个纹理，以便在渲染到另一个纹理时显示这个纹理的内容。&lt;/p>
&lt;p>为了绘制，需要创建一个渲染通道（render pass），它是一系列用于绘制纹理的渲染指令。在渲染通道被使用时，纹理也被称为渲染目标。为创建一个渲染通道，首先需要一个MTLRenderPassDescriptor的指针。在本示例中，是通过MetalKit获取，而不是配置自己的渲染通道描述符。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">MTLRenderPassDescriptor&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">renderPassDescriptor&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">view&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">currentRenderPassDescriptor&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">renderPassDescriptor&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>渲染通道描述符描述了一组渲染目标，以及在渲染通道的开始和结束时应该如何处理它们。 渲染过程还定义了不属于此示例的渲染的其他一些方面。 视图返回一个带有单个color attchment的渲染通道描述符，该attchment指向视图的纹理之一，否则根据视图的属性配置渲染通道。 默认情况下，这意味着在渲染过程开始时，渲染目标被擦除为与视图的 clearColor 属性匹配的纯色，并且在渲染过程结束时，所有更改都将存储回纹理。&lt;/p>
&lt;p>由于一个视图的渲染通道可能为空（nil），因此需要在创建渲染通道之前测试渲染通道描述符（Render Pass Descriptor）是否为空。&lt;/p>
&lt;h2 id="创建一个渲染通道">创建一个渲染通道&lt;/h2>
&lt;p>创建一个渲染通道（render pass）并将其放入指令缓存（command buffer）中需要使用一个MTLRenderCommandEncoder对象，可通过调用command buffer的 makeRenderCommandEncoder(descriptor:)，并把render pass descriptor参数传入，以完成MTLRenderCommandEncoder对象的创建。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLRenderCommandEncoder&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">commandEncoder&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">commandBuffer&lt;/span> &lt;span class="n">renderCommandEncoderWithDescriptor&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">renderPassDescriptor&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在本示例中，不需要编写任何绘制指令，tender pass唯一需要做的就是清除texture，通过调用编码器的endEncodeing函数，以注明渲染已经完成。&lt;/p>
&lt;h2 id="在屏幕上显示一个drawable">在屏幕上显示一个Drawable&lt;/h2>
&lt;p>绘制到纹理不会自动在屏幕上显示新内容。 实际上，屏幕上只能呈现一些纹理。 在 Metal 中，可以在屏幕上显示的纹理由可绘制对象（Drawable）管理，并且要显示内容，您需要呈现可绘制对象。&lt;/p>
&lt;p>MetalKit会自动的Drawable去管理它的纹理，读取 currentDrawable 属性以获取拥有作为render pass目标纹理的可绘制对象。 视图返回一个 CAMetalDrawable 对象，它是一个连接到Core Animation的对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLDrawable&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">drawable&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">view&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">currentDrawable&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在command buffer上调用present(_:),并传递drawable&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">commandBuffer&lt;/span> &lt;span class="n">presentDrawable&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">drawable&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法告诉 Metal，当command buffer被执行时，Metal 应该与 Core Animation 协调以在渲染完成后显示纹理。 当 Core Animation 呈现纹理时，它成为视图的新内容。 在此示例中，这意味着已擦除的纹理将成为视图的新背景。 该更改与 Core Animation 为屏幕用户界面元素所做的任何其他视觉更新一起发生。&lt;/p>
&lt;h2 id="提交command-buffer">提交Command Buffer&lt;/h2>
&lt;p>现在已完成绘制那一帧的全部指令，最终提交Command Buffer&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">commandBuffer&lt;/span> &lt;span class="n">commit&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Apple Metal文档（1）：在GPU上进行计算</title><link>https://ingslh.com/post/2022-09-01-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-1/</link><pubDate>Sun, 04 Sep 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-09-01-applemetal%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87-1/</guid><description>&lt;blockquote>
&lt;p>本文翻译自苹果Metal的官方文档：&lt;a href="https://developer.apple.com/documentation/metal/performing_calculations_on_a_gpu">Performing Calculations on a GPU&lt;/a>，如果哪里翻译有误，请大家指出，我会及时更正。欢迎转载，但禁止用于商业用途。谢谢！&lt;/p>
&lt;/blockquote>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>在这个例程中，你将学习到在所有Metal程序中所用到的基本任务。你将看到如何把一个简单的c语言程序转换成Metal着色器语言（MSL），并使其能够在GPU上运行。你会找到一个GPU，通过创建管线准备使MSL函数在GPU上运行，并构造GPU能够访问的数据对象。针对你的数据对象去运行管线，首先创建一个命令缓存区，将命令写入其中，然后将缓存区提交到命令队列，最后Metal将命令发送到GPU，并执行它们。&lt;/p>
&lt;h2 id="编写一个gpu函数来执行计算">编写一个GPU函数来执行计算&lt;/h2>
&lt;p>为讲解GPU编程，给出一个两数组对应位求和，并把结果放进第三个数组的示例程序。示例1为在cpu上运行上述运算的C程序，通过遍历索引index，在每次循环中计算result。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">add_arrays&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于每一次计算是相对独立的，因此这两个数组每一位上的求和是可以同步进行的。为了能够在GPU上运行这个程序，需要将这个函数重写成Metal的着色器语言（MSL）。MSL为GPU编程而设计的c++变体。其中，运行在GPU的代码被称为着色器（shader），这是由于这类GPU程序曾首先被应用于计算3D图像中的颜色。示例2展示了与示例1进行同样运算的MSL shader。在官方给出的示例代码中，这个函数定义在add.metal。使用Xcode构建并创建一个默认的Metal库，它会被嵌入到应用程序中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">kernel&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add_arrays&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">device&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">device&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uint&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">thread_position_in_grid&lt;/span>&lt;span class="p">]])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// the for-loop is replaced with a collection of threads, each of which
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// calls this function.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inA&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">inB&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>示例2与示例1相似，当在MSL版本中，有一些重要的区别。仔细观察示例2.&lt;/p>
&lt;p>首先，这个函数加了一个kernel关键字，使这个函数被声明为：&lt;/p>
&lt;ol>
&lt;li>公共（public）GPU函数，程序在调用这个Metal库时，public是仅可见的函数，同时public函数不能被其他shader程序调用。&lt;/li>
&lt;li>计算函数（也称为计算kernel），它通过线程网格（gird）完成并行计算。&lt;/li>
&lt;/ol>
&lt;p>如需了解其他用于声明public图形函数的关键字，请参阅&lt;a href="https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives">使用渲染管道渲染图元&lt;/a>。&lt;/p>
&lt;p>add_arrays 函数用 device 关键字声明了它的三个参数，这表示这些数组指针位于Device地址空间中。MSL定义了若干不相邻的内存区域，每当在MSL中声明一个指针，必须使用一个关键字来声明它的内存地址。使用device修饰的地址空间，代表GPU可以对其进行持续的读写。&lt;/p>
&lt;p>示例2移除了示例1的for循环，因为是被gird中的多线程调用的，这个示例创建了一个与数组维度一致的一维线程网格，因此数组中每一个数值求和是不同线程完成计算的。&lt;/p>
&lt;p>同时示例2使用了一个新的index索引变量替代之前在for循环中的索引，index通过c++的&lt;a href="https://en.cppreference.com/w/cpp/language/attributes">attribute&lt;/a>被赋值为另一个MSL关键词：&lt;em>thread_position_in_grid&lt;/em>，这个关键字表明 Metal 会为每个线程计算一个唯一的索引，并将索引传递给变量。因为add_arrays使用了一维gird，因此index定义为整数（uint）。尽管for循环被移除，示例1和示例2使用相同的方式完成求和。如果想将类似的代码从c/c++转换为MSL，可以使用相同的方式循环逻辑的替换。&lt;/p>
&lt;h2 id="检索gpu">检索GPU&lt;/h2>
&lt;p>在应用程序中，&lt;strong>MTLDevice&lt;/strong>代表一个GPU的简单抽象（Metal设备对象），可通过它完成与GPU的通信。Metal为每一个GPU创建一个MTLDevice，并可通过调用MTLCreateSystemDefaultDevice()获取默认的设备对象。在 macOS 中，Mac 可以有多个 GPU，Metal 会选择其中一个 GPU 作为默认值并返回该 GPU 的MTLDevice，Metal也提供了用于检索所有GPU的其他API，但此示例仅使用默认值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLDevice&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">device&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MTLCreateSystemDefaultDevice&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="初始化metal对象">初始化Metal对象&lt;/h2>
&lt;p>Metal将其他与GPU相关的工作（如编译shader、内存缓存区、图像纹理）表示为不同对象。要创建这些特定的GPU对象。可以通过调用MTLDevice和派生于MTLDevice对象的方法创建这些特定的GPU对象。由GPU的MTLDevice对象直接或间接创建的所有对象仅可用于对应的GPU，对于使用多个GPU的应用程序，Metal会创建多个GPU对象，并为每个对象创建类似的Metal层次结构。&lt;/p>
&lt;p>示例程序中使用一个自定义的类MetalAdder来管理需要与GPU进行通信的对象，在类的初始化中会创建这些对象，并存储在其属性中。在程序中会创建一个该类的示例，传入用于创建辅助对象的 Metal 设备对象。这个MetalAdder对象会在生命周期内保持对Metal对象的强引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">MetalAdder&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">adder&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">MetalAdder&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">initWithDevice&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在Metal中，高消耗的初始化任务可以一次运行之后，将结果保留并在低消耗情况下被使用。很少情况下需要在性能要求严格的代码中执行此类任务。&lt;/p>
&lt;h2 id="调用metal函数">调用Metal函数&lt;/h2>
&lt;p>初始化首先加载这些函数，同时准备在GPU上运行他们。当在build示例程序时，XCode会编译add_arrays函数到一个默认的Metal库，后续应用层会完成对其的调用。使用&lt;strong>MTLLibray&lt;/strong>和&lt;strong>MTLFunction&lt;/strong>的对象去获取Metal库和库中所包含的函数。为获取代表add_array的对象首先需要让MTLDevice为默认库创建一个MTLLibrary对象，然后向库请求一个表示shader函数的MTLFunction对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="o">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">instancetype&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">initWithDevice&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLDevice&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="n">device&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kc">self&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="kc">super&lt;/span> &lt;span class="kd">init&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kc">self&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_mDevice&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">device&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">NSError&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">error&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Load the shader files with a .metal file extension in the project&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLLibrary&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">defaultLibrary&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newDefaultLibrary&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">defaultLibrary&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">NSLog&lt;/span>&lt;span class="p">(@&lt;/span>&lt;span class="s">&amp;#34;Failed to find the default library.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLFunction&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">addFunction&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">defaultLibrary&lt;/span> &lt;span class="n">newFunctionWithName&lt;/span>&lt;span class="p">:@&lt;/span>&lt;span class="s">&amp;#34;add_arrays&amp;#34;&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">addFunction&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">NSLog&lt;/span>&lt;span class="p">(@&lt;/span>&lt;span class="s">&amp;#34;Failed to find the adder function.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="准备metal渲染管线">准备Metal渲染管线&lt;/h2>
&lt;p>上面的函数对象addFunction代表已完成的MSL函数，但它并不是能够直接运行的，需要通过创建一个管线（&lt;em>pipline&lt;/em>），使其能够被执行。pipline会让GPU明确完成一个特定任务所需要执行的步骤。在Metal，pipline会被一个管线状态对象所表示，因为在例程中，两数求和是一个计算函数，因此使用&lt;strong>MTLComputePiplineState&lt;/strong>完成管线对象的创建。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">_mAddFunctionPSO&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newComputePipelineStateWithFunction&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">addFunction&lt;/span> &lt;span class="n">error&lt;/span>&lt;span class="p">:&amp;amp;&lt;/span>&lt;span class="n">error&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>计算pipline会运行单个计算函数，可选地在运行函数之前处理输入数据，运行之后处理输出数据。&lt;/p>
&lt;p>当创建管线状态对象时，设备对象会为特定的GPU编译好需要执行的函数。在示例中，会同步创建管道状态对象，并将其直接返回给应用程序。 因为编译确实需要一段时间，所以避免在性能敏感代码中同步创建管道状态对象。&lt;/p>
&lt;p>&lt;em>原文注：到目前为止，在代码中看到的所有 Metal 返回的对象都是作为符合协议的对象返回的。 Metal 使用协议定义了大多数GPU的特有对象，以完成底层实现类的抽象，这些实现类可能因不同的 GPU 而异。 Metal 使用这些类定义与GPU所独有的对象。 对于是否可以在应用程序中实现该协议可以参阅Metal的参考文档。&lt;/em>&lt;/p>
&lt;h2 id="创建一个指令队列command-queue">创建一个指令队列（Command Queue）&lt;/h2>
&lt;p>向GPU发送工作任务，需要使用指令队列（command queue）实现，同时Metal会使用指令队列，完成对指令的调度。通过MTLDevice完成指令队列的创建。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">_mCommandQueue&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newCommandQueue&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建数据缓存区并加载数据">创建数据缓存区并加载数据&lt;/h2>
&lt;p>在创建好基本的Metal对象之后，需要加在数据以供GPU执行，此任务对性能的要求不高，但最好也在应用程序启动时执行，避免性能损耗。&lt;/p>
&lt;p>GPU可以拥有自己的专用内存，也可以与操作系统共享内存。Metal和操作系统内核需要执行额外的工作才能将数据存储在内存中，并使这些数据可供GPU使用。Metal使用资源类（MTLResource）完成内存资源的管理。resource是GPU在运行命令时可以访问的内存区域。可使用MTLDevice完成对其GPU的resource的创建。&lt;/p>
&lt;p>在示例程序中，创建了三个MTLBuffer，其中前两个使用随机数填充，第三个用来存放add_array的结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">_mBufferA&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newBufferWithLength&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">bufferSize&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">MTLResourceStorageModeShared&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">_mBufferB&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newBufferWithLength&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">bufferSize&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">MTLResourceStorageModeShared&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">_mBufferResult&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mDevice&lt;/span> &lt;span class="n">newBufferWithLength&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">bufferSize&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">MTLResourceStorageModeShared&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="kc">self&lt;/span> &lt;span class="n">generateRandomFloatData&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mBufferA&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="kc">self&lt;/span> &lt;span class="n">generateRandomFloatData&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mBufferB&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在本示例中，resource为这些MTLBuffer对象，它们是没有预定义格式的内存分配。Metal 将每个缓冲区作为不透明的字节集合进行管理。 但是在shader中使用缓冲区时会指定数据格式。 这意味着shader和应用程序需要就来回传递的任何数据的格式进行统一。&lt;/p>
&lt;p>当分配一个buffer时，需要提供一种存储形式来确定它的一些性能特征，同时需明确CPU/GPU是否可以访问它。在示例程序中，使用共享内存（&lt;a href="https://developer.apple.com/documentation/metal/mtlresourceoptions/1515613-storagemodeshared">storgeModeShared&lt;/a>）来保证CPU和GPU能够访问。&lt;/p>
&lt;p>为向buffer内填随机数，应用程序获取了buffer的指针，并使用cpu向其中写数据。示例2中的arr_arrays函数声明了它的参数为float型的数组指针，所以需要保证buffer内的数据与其类型一致。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="o">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">generateRandomFloatData&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLBuffer&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="n">buffer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">dataPtr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contents&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">unsigned&lt;/span> &lt;span class="n">long&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arrayLength&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dataPtr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">float&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">rand&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">float&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">RAND_MAX&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建一个指令缓存区command-buffer">创建一个指令缓存区（Command Buffer）&lt;/h2>
&lt;p>使用指令队列（_mCommandQueue）对象创建一个指令缓存区。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLCommandBuffer&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">commandBuffer&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">_mCommandQueue&lt;/span> &lt;span class="n">commandBuffer&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建一个指令编码器command-encoder">创建一个指令编码器（Command Encoder）&lt;/h2>
&lt;p>为了向指令缓存中写指令，需要使用Command Encoder来处理编码时的特定指令。此示例创建一个计算命令编码器，该编码器对计算通道进行编码。 计算通道包含执行计算管道的命令列表。 每个计算命令都会使 GPU 创建一个线程网格以在 GPU 上执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">id&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MTLComputeCommandEncoder&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">computeEncoder&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">commandBuffer&lt;/span> &lt;span class="n">computeCommandEncoder&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要对指令进行编码，需要对编码器进行一系列方法的调用，其中主要为设置状态信息，如管道状态对象 (pipeline state object,PSO) 或要传递给管道的参数。 进行这些状态更改后，命令进行编码以执行pipline。编码器会将所有状态变化和命令参数写入命令缓冲区。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0904/command_encoder.png" alt="指令编码器">&lt;/p>
&lt;h2 id="设置管线状态和参数信息">设置管线状态和参数信息&lt;/h2>
&lt;p>首先需要设置对应pipline的状态，即PSO，然后针对需要发送到add_arrays函数的每一个参数进行配置。对于此pipline，需要对三个buffer进行配置。 Metal 按照参数出现在示例2中的顺序自动为buffer参数分配索引，从 0 开始。您使用相同的索引提供参数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">setComputePipelineState&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mAddFunctionPSO&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">setBuffer&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mBufferA&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="n">atIndex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">setBuffer&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mBufferB&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="n">atIndex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">setBuffer&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_mBufferResult&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="n">atIndex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时也需要制定参数的偏移量（offset），当偏移量为0时，表明command会从buffer的起始位置获取参数。但也可以使用一个buffer存储多个参数，为每一个参数指定一个独立的offset。&lt;/p>
&lt;p>可以看出，程序中没有为add_arrays的index参数指定任何数据，这是由于该值由GPU提供。&lt;/p>
&lt;h2 id="指定线程数并组织线程">指定线程数并组织线程&lt;/h2>
&lt;p>下一步，确定需要创建多少线程，并如何组织这些线程。Metal能够创建一维、二维、三维的线程网格。由于add_arrays使用的是一维数组，所以例程中创建了一个长度为数组长度的一维网格&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">MTLSize&lt;/span> &lt;span class="n">gridSize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MTLSizeMake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arrayLength&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="指定线程组threadgroup大小">指定线程组（Threadgroup）大小&lt;/h2>
&lt;p>Metal为网格细分为更小的结构，叫做线程组（Threadgroup）。每个线程组都是单独计算的。 Metal 可以将线程组分派给 GPU 上的不同处理元素以加快处理速度。 同样也需要决定为指令创建对应尺寸的线程组。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="n">NSUInteger&lt;/span> &lt;span class="n">threadGroupSize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_mAddFunctionPSO&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">maxTotalThreadsPerThreadgroup&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">threadGroupSize&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arrayLength&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threadGroupSize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayLength&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">MTLSize&lt;/span> &lt;span class="n">threadgroupSize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MTLSizeMake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">threadGroupSize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在例程中，使用PSO获取了最大的线程组尺寸，如果这个长度大于参数的本身长度，则需要调整threadGroupSize为对应的大小。&lt;/p>
&lt;p>maxTotalThreadsPerThreadgroup 属性给出线程组中允许的最大线程数，这取决于用于创建管道状态对象的函数复杂性。&lt;/p>
&lt;h2 id="编码计算指令并在线程中执行">编码计算指令并在线程中执行&lt;/h2>
&lt;p>最后，对指令进行编码去分配线程网格。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">dispatchThreads&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">gridSize&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threadsPerThreadgroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">threadgroupSize&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当GPU运行这个指令，会使用先前设置好的状态和命令的参数来调度线程来执行计算。
可以使用编码器按照相同的步骤将多个计算命令编码到计算通道中，而无需执行任何冗余步骤。 例如，可以设置管道状态对象一次后，设置参数为要处理的每个缓冲区集合编码一个命令。&lt;/p>
&lt;h2 id="结束计算通道">结束计算通道&lt;/h2>
&lt;p>当没有更多的指令进入计算通道时，需要结束编码关闭计算通道。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">computeEncoder&lt;/span> &lt;span class="n">endEncoding&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="提交命令缓冲区以执行其命令">提交命令缓冲区以执行其命令&lt;/h2>
&lt;p>指令缓冲（command buffer）提交命令到指令队列（command queue），然后queue来运行命令缓冲区中的命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">commandBuffer&lt;/span> &lt;span class="n">commit&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>指令队列创建了指令缓存，因此提交缓存总是将其放入队列中。在提交指令缓存后，Metal会进行预处理操作，然后安排command buffer在GPU上执行。GPU在执行完缓存中的command之后，Metal会将缓存区标记成已完成。&lt;/p>
&lt;h2 id="等待计算完成">等待计算完成&lt;/h2>
&lt;p>在GPU处理command的时候，应用程序可以完成其他的工作，在示例程序中，应用层不需要处理额外的工作，所以只需要简单地等待command buffer完成任务。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">commandBuffer&lt;/span> &lt;span class="n">waitUntilCompleted&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样的，也可在Metal完成command的时候，向command buffer添加一个完成的句柄（handler），也可以读取command buffer的状态属性，获取command是否完成。&lt;/p>
&lt;h2 id="从缓存中读取结果">从缓存中读取结果&lt;/h2>
&lt;p>在command buffer完成之后，GPU的计算结果存储在输出缓存中，Metal需要执行一些必要的步骤使其能够被CPU所读取。在一个真正的应用程序中，你可以在输出中读到结果，并在之后可对其进行相关操作，例如在屏幕上显示，或把它们写入文件。由于例程仅用于说明创建 Metal 应用程序的过程，因此只会读取存储在输出缓冲区中的值并进行测试以确保 CPU 和 GPU 计算出相同的结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="o">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">verifyResults&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_mBufferA&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contents&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_mBufferB&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contents&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_mBufferResult&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contents&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">unsigned&lt;/span> &lt;span class="n">long&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arrayLength&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Compute ERROR: index=%lu result=%g vs %g=a+b&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">index&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Compute results as expected&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>MVC MVP MVVM架构浅析</title><link>https://ingslh.com/post/2022-06-18-mvc-mvp-mvvm%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</link><pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-06-18-mvc-mvp-mvvm%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/</guid><description>&lt;p>&lt;strong>MVC&lt;/strong>、&lt;strong>MVP&lt;/strong>和&lt;strong>MVVM&lt;/strong>是三种用以实现软件系统中用户界面与逻辑层解耦的抽象架构模型，其中后两种算是&lt;strong>MVC&lt;/strong>的变形。作为三种最常用的三种架构设计模式，它们有着各自不同的的应用场景，结合自己之前的经验，来简单总结下它们的特点。&lt;/p>
&lt;p>&lt;em>在实际开发中，选用的架构可以看作是一种骨架，结合业务需求往往需要在骨架的基础上进行一些改造并丰富细节。&lt;/em>&lt;/p>
&lt;h2 id="mvc">MVC&lt;/h2>
&lt;p>MVC（Model-View-Controller）模式主要分为三个部分，分别是模型、视图和控制器。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mvc.png" alt="MVC结构图">&lt;/p>
&lt;ul>
&lt;li>模型（Model）：处理底层业务逻辑，实现相关运算；&lt;/li>
&lt;li>视图（View）：页面显示，完成与用户的交互；&lt;/li>
&lt;li>控制器（Controller）：完成模型与视图的数据（或命令）通信，完成应用层面的相关任务；&lt;/li>
&lt;/ul>
&lt;p>从上图的通信流程图来看，三个模块间的通信是单向的，首先用户操作视图，传达相应的指令到控制器，控制器将指令解析，传递给模型进行相应的处理，如果需要将结果反馈给视图，则再将指令传递给视图，最终视图完成更新。&lt;/p>
&lt;h2 id="mvp">MVP&lt;/h2>
&lt;p>MVP(Model-View-Presenter)是从经典的MVC演变过来的，但是由于model和view之间不进行直接连接，而是将presenter作为桥梁，完成从view到model到数据传输，以及从model到view到界面更新。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mvp.png" alt="MVP结构图">&lt;/p>
&lt;p>它的特点总结是：&lt;/p>
&lt;ul>
&lt;li>各部分之间的通信，是双向的；&lt;/li>
&lt;li>Presenter就是相对于MVC中的Controller，为了便于区分，将控制器命名为Presenter；&lt;/li>
&lt;li>Presenter可以对应多个view，控制接口后，能应对来自于view的复杂变化；&lt;/li>
&lt;/ul>
&lt;p>从结构上来看，mvp中因为view与model不直接通信，降低了整个系统的耦合程度，相比较mvc来说，view由于只被动地处理界面，因此被称为“被动视图”（Passive View），随之而来造成presenter的变重，除了要完成整个业务逻辑的实现，还要加上对view的控制。&lt;/p>
&lt;h2 id="mvvm">MVVM&lt;/h2>
&lt;p>MVVM（Model-View-ViewModel），最大的区别是将控制器（controller/presenter）换成了ViewModel（VM），与之对应的VM在功能方面，也进行了更新。&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mvvm.png" alt="MVVM结构图">&lt;/p>
&lt;p>从结构图来看，与MVP的变化不大，但对于VM来说，它与model采用双向绑定（data-binding）的形式，即如果View和ViewModel任意一方发生变化时，另一方会自动更新。&lt;/p>
&lt;h2 id="在多视图下的应用">在多视图下的应用&lt;/h2>
&lt;p>考虑一种“&lt;strong>复杂软件&lt;/strong>”的情况，即主视图（parent-view）下存在着多个子视图（child-view），每个视图之间的业务逻辑各不相同，但从界面的角度来说又各自关联，如何套用到上述的三种模型中呢？&lt;/p>
&lt;p>以&lt;strong>MVP&lt;/strong>模型举例，当然可以把多个视图抽象成一个整体，这样看就与前面的流程图差不多，但从模型和presenter的角度来说，它们会变得很臃肿且耦合度高（在presenter/model下，将所有view对应的指令和实现放在一起）。&lt;/p>
&lt;p>在尽可能低耦合的目标下，可以针对每一个view，构建对应的model和presenter，其中presenter不单要完成模块内（与自身model和view）的指令传递，也要完成与其他模块（其他presenter）的通信，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/0617/mulit-view.png" alt="多视图下的应用">&lt;/p>
&lt;p>如果这个&lt;strong>复杂软件&lt;/strong>需要多个开发人员协作时，只要把presenter间的接口确定好，每个开发人员可以最大程度上专注于自己所负责模块的功能实现。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>最后以一句老生常谈的话作为总结：&lt;/p>
&lt;blockquote>
&lt;p>适用于任何情况的架构设计模型是不存在的，只能在结合实际需求的情况下寻找或创造一种&lt;strong>相对&lt;/strong>适合的模型。&lt;/p>
&lt;/blockquote>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://henleylee.github.io/posts/2019/de9d67a4.html">MVC、MVP 和 MVVM 之间的区别&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">MVC，MVP 和 MVVM 的图示&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/6901200799242649607">正确认识 MVC/MVP/MVVM&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Hugo + Github Pages搭站记录</title><link>https://ingslh.com/post/2022-06-10-hugo+githubpages%E6%90%AD%E7%AB%99%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/post/2022-06-10-hugo+githubpages%E6%90%AD%E7%AB%99%E8%AE%B0%E5%BD%95/</guid><description>&lt;p>伴随Web技术的蓬勃发展，使得构建静态网站的成本越来越低，这个博客是通过Hugo和GitHub Pages完成的构建，作为博客的第一篇文章，主要介绍下这个博客的搭建过程，虽然现在网上相关的资料已经非常丰富，但是我在建站的过程中还是遇到了很多问题，抱着分享与总结的目的，在这里记录下我的实现流程供大家参考。🌟&lt;/p>
&lt;h3 id="文中所使用的软件版本">文中所使用的软件版本&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Version&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Hugo&lt;/td>
&lt;td>0.98&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Git&lt;/td>
&lt;td>2.36&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>如果需要编译Hugo源码,需要Go1.3+&lt;/em>&lt;/p>
&lt;h3 id="简述">简述&lt;/h3>
&lt;p>在github上建立两个仓库，一个作为&lt;strong>源码仓库&lt;/strong>(&lt;em>user.github.io.src&lt;/em>)，另一个作为用于&lt;strong>主页仓库&lt;/strong>(&lt;em>user.git.io&lt;/em>)。将主页仓库作为源码仓库的子模块，利用Github Actions，使源码repo在push时将编译结果输出到主页repo中，然后页面repo利用GitHub Pages渲染实现一个博客站点。一般将源码repo设为私有库，同时并不影响主页repo里的页面展示。&lt;/p>
&lt;blockquote>
&lt;p>与此同时，还有两种实现方式：一种是使用Hugo创建的site主目录作为Github Pages的运行根，还有一种是使用hugo编译后的publishDir作为Github Pages的运行根。两种方式都能够渲染出页面，但也都有各自的问题：第一种方式会暴露你的相关信息，例如配置文件下的个人信息，未发表的草稿等等都会展示在github上；第二种方式由于没有git仓库建立在你的源码目录上，因此不能进行有效的版本管理，维护起来会很麻烦。&lt;/p>
&lt;/blockquote>
&lt;h2 id="主要流程">主要流程&lt;/h2>
&lt;h3 id="1安装hugo和git">1.安装hugo和git&lt;/h3>
&lt;p>hugo和git都可通过官网上的指南进行安装，&lt;a href="https://gohugo.io/getting-started/installing/">Install Hugo｜Hugo&lt;/a> 和&lt;a href="https://git-scm.com/downloads">Git-Downloads&lt;/a>;&lt;/p>
&lt;p>在终端输入&lt;code>hugo version&lt;/code>和&lt;code>git version&lt;/code>验证是否安装成功。&lt;/p>
&lt;h3 id="2创建github仓库">2.创建Github仓库&lt;/h3>
&lt;p>创建如下图所示的两个&lt;strong>空&lt;/strong>仓库，其中将用户名替换成自己的，源码仓库（&lt;em>user.github.io.src&lt;/em>）命名可以任意，但是为了便于区分，加上了后缀 &lt;strong>.src&lt;/strong>。
&lt;img src="https://ingslh.com/img/github_repo.jpeg" alt="">&lt;/p>
&lt;h3 id="3新建hugo网站">3.新建Hugo网站&lt;/h3>
&lt;p>通过终端将源码库（&lt;em>user.github.io.src&lt;/em>）clone到本地，进入该文件夹，使用&lt;code>hugo new&lt;/code>创建Hugo网站&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git clone https://github.com/user/user.github.io.src.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> user.github.io.src
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">hugo new site . --force
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这里没有现在本地创建git仓库的原因是，新建本地仓库的默认分支为&lt;code>master&lt;/code>，而github上新建仓库的默认分支为&lt;code>main&lt;/code>，连接远程仓库的时候，要再建一个&lt;code>main&lt;/code>分支，并把&lt;code>master&lt;/code>分支删去。&lt;/p>
&lt;/blockquote>
&lt;h3 id="4添加主题">4.添加主题&lt;/h3>
&lt;p>需要为新建的site选择一个合适的主题，可以在&lt;a href="https://themes.gohugo.io">Hugo Themes&lt;/a>挑选一个自己喜欢的，在挑选主题时，建议先看下所用主题的README，下面就以本站使用的&lt;strong>BeautifulHugo&lt;/strong>举例；&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ mkdir themes &lt;span class="c1">#在源码repo的根目录下执行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ &lt;span class="nb">cd&lt;/span> themes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git submodule add https://github.com/halogenica/beautifulhugo.git beautifulhugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样&lt;code>themes&lt;/code>的文件夹下会有&lt;code>beautifulhugo&lt;/code>的主题了，由于是建立的新hugo工程，可以根据&lt;code>exampleSite&lt;/code>下的&lt;code>config.toml&lt;/code>修改自己的主目录下的&lt;code>config.toml&lt;/code>，&lt;strong>建议直接拷贝过去，再修改上自己的一些信息。&lt;/strong>&lt;/p>
&lt;p>一开始也可以把&lt;code>exampleSite&lt;/code>下的&lt;code>content&lt;/code>文件夹复制到主目录进行覆盖。&lt;/p>
&lt;blockquote>
&lt;p>一般&lt;code>exampleSite&lt;/code>会有&lt;code>content&lt;/code>、&lt;code>layouts&lt;/code>、&lt;code>static&lt;/code>文件夹，可以根据自己需要把它们拷贝到主目录下。&lt;/p>
&lt;/blockquote>
&lt;p>然后就可以通过hugo的&lt;code>server&lt;/code>命令，预览主题效果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ hugo server &lt;span class="c1">#如果希望显示草稿（draft）可以加上 —D&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当返回信息包含如下时，可进入&lt;a href="http://localhost:1313/">http://localhost:1313/&lt;/a>进行预览。&lt;/p>
&lt;blockquote>
&lt;p>如果效果异常，大概率是配置文件（config.toml）修改得不正确。请参照所使用主题的README和Hugo的官方文档进行检查。&lt;/p>
&lt;/blockquote>
&lt;h3 id="5配置token">5.配置token&lt;/h3>
&lt;p>下面需要为Github Actions的自动部署配置token，配置方法如下：&lt;/p>
&lt;p>首先通过github生成token，在你的github主页下点击头像框，依次进入&lt;strong>Setting-&amp;gt;Developer Settings-&amp;gt;Personal access tokens&lt;/strong>&lt;/p>
&lt;p>选择Generate new token，按规则填入note和expiration，其中expiration可以尽量填大一些，避免后续需要频繁更新。&lt;/p>
&lt;p>勾选下面的&lt;code>repo&lt;/code>和&lt;code>admin:repo_hook&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://ingslh.com/img/token_config.png" alt="配置token">&lt;/p>
&lt;p>点击&lt;code>Generate token&lt;/code>进行生成，并复制token。&lt;/p>
&lt;p>生成后需要在源码repo中添加新生成的token，在github的源码repo中通过Settings-&amp;gt;Secrets-&amp;gt;Actions进入，填写Name和Value，其中Name可以自己定义（我定义的是ACTION_ACCESS_TOKEN，后续配置workflow会用到），Value中填入之前复制的token。&lt;/p>
&lt;blockquote>
&lt;p>实现Actions的自动部署还有一种方式是关联源码repo和页面repo的ssh key，过程会相对繁琐些，且在实际配置后，push源码repo时，Actions会报错&lt;code>Action failed with &amp;quot;The process '/usr/bin/ssh-add' failed with exit code 1&amp;quot;&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h3 id="6设置workflow">6.设置workflow&lt;/h3>
&lt;p>生成token后，在源码仓库的Actions中新建一个workflow，根据&lt;a href="https://github.com/peaceiris/actions-hugo#getting-started">Github Actions for Hugo&lt;/a>进行填写，我的workflow.yml如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy Hugo Site to Github Pages on Main Branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">push&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">branches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build-deploy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-18.04&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v1 &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># v2 does not have submodules option now&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">submodules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">fetch-depth&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch all history for .GitInfo and .Lastmod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Setup Hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-hugo@v2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#hugo官方提供的action，用于在任务环境中获取hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">hugo-version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;latest&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># extended: true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Build&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hugo --minify&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#构建静态网页，默认存在publish文件夹下&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-gh-pages@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">personal_token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.ACTION_ACCESS_TOKEN }}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># ACTION_ACCESS_TOKEN修改成之前填写secret的名字&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">external_repository&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">username/ingslh.github.io&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Pages远程仓库,更换username &lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_dir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#默认发布public文件夹里的内容&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">keep_files&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># remove existing files&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_branch&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># deploying branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">commit_message&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ github.event.head_commit.message }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>commit后该yml会生成在repo的./github/worksflows下。&lt;/p>
&lt;h3 id="7自动部署发布">7.自动部署发布&lt;/h3>
&lt;p>在本地的源码仓库的根目录下中提交修改到远程库，actions会自动帮你把hugo编译的静态页面推送到页面repo中，完成部署。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git add .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s2">&amp;#34;commit info&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git pull --rebase &lt;span class="c1">#由于远程库更新了workflow文件，所以需要pull下&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回到github的源码repo中，点击Actions，查看自动部署是否成功，如果成功部署会出现如下结果：
&lt;img src="https://ingslh.com/img/actions_success.png" alt="部署成功">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>至此已完成了通过Hugo+Github pages对个人博客的搭建，其实对于初始博客还有很多地方可以优化，比如加入评论系统，加入暗色模式，对多语言的支持等等，之后的更新也同样会进行记录。😄&lt;/p></description></item><item><title>About me</title><link>https://ingslh.com/page/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ingslh@foxmail.com (ingslh)</author><guid>https://ingslh.com/page/about/</guid><description>&lt;p>😄Hi！欢迎来到我的博客，我是ingslh，一名c/c++程序员，平时主要做一些音视频开发、图形图像渲染的工作，目前坐标长沙。&lt;/p>
&lt;p>一些爱好：&lt;/p>
&lt;ul>
&lt;li>🎵：后朋(&lt;em>PostPunk&lt;/em>)、放克(&lt;em>Funk&lt;/em>);&lt;/li>
&lt;li>🎮：杀戮尖塔（&lt;em>Slay the Spire&lt;/em>）、极乐迪斯科(&lt;em>Disco Elysium&lt;/em>);&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;em>不太好写，随便写一些近期的&lt;/em>🤔&lt;/p>
&lt;/blockquote>
&lt;p>关于职场身份，理想是成为一名独立开发者，希望有生之年能实现吧。&lt;/p>
&lt;p>建立这个博客的目的是记录我在工作和平时折腾的过程中遇到的一些问题与解决这些问题的收获。&lt;/p>
&lt;p>最后想分享下吴军博士提出的工程师的“五个等级”：&lt;/p>
&lt;ul>
&lt;li>5.能独立解决问题，完成工程工作；&lt;/li>
&lt;li>4.指导和带领其他人一起完成更有影响力的工作；&lt;/li>
&lt;li>3.独立设计和实现产品，并在市场上成功；&lt;/li>
&lt;li>2.设计和实现别人不能做的产品；&lt;/li>
&lt;li>1.开创一个产业；&lt;/li>
&lt;/ul>
&lt;p>&lt;em>自评下，我应该5还没有达到&lt;/em> :(&lt;/p></description></item></channel></rss>